<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>EMBERWING // HAVEN</title>
<style>
  :root{
    --bg0:#05070b;
    --bg1:#071225;
    --bg2:#123a66;
    --bg3:#4f9ac6;
    --ink:#dbe7ff;
    --muted:rgba(219,231,255,.72);
    --dim:rgba(219,231,255,.46);
    --line:rgba(219,231,255,.14);
    --glass0:rgba(10,16,30,.38);
    --glass1:rgba(10,16,30,.16);
    --shadow:rgba(0,0,0,.55);
    --warm:rgba(255,210,160,.9);
    --cool:rgba(140,220,255,.85);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    --r:14px;
  }
  html,body{height:100%;margin:0;overflow:hidden;background:var(--bg0);color:var(--ink);}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block;}
  /* HUD */
  #hud{
    position:fixed; inset:0; pointer-events:none; user-select:none;
    font-family:var(--sans); letter-spacing:.2px;
  }
  .glass{
    background:linear-gradient(180deg,var(--glass0),var(--glass1));
    border:1px solid var(--line);
    border-radius:var(--r);
    box-shadow:0 18px 55px var(--shadow);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
  }
  .topbar{
    position:absolute; left:18px; right:18px; top:14px;
    display:flex; justify-content:space-between; gap:12px; align-items:flex-start;
  }
  .brand{
    padding:12px 14px; max-width:min(640px,62vw);
    display:flex; flex-direction:column; gap:6px;
  }
  .title{
    font-family:var(--mono); font-size:12px; text-transform:uppercase;
    display:flex; align-items:center; gap:10px; color:rgba(219,231,255,.92);
  }
  .dot{
    width:8px;height:8px;border-radius:999px;
    background:radial-gradient(circle at 30% 30%, rgba(255,220,180,1), rgba(255,190,120,.18));
    box-shadow:0 0 16px rgba(255,190,120,.45);
  }
  .badge{
    font-family:var(--mono); font-size:10px; padding:3px 8px;
    border-radius:999px; border:1px solid var(--line);
    color:rgba(219,231,255,.82); background:rgba(10,16,30,.14);
    margin-left:6px;
  }
  .subtitle{font-size:12.5px;color:var(--muted);line-height:1.25}
  .subtitle b{color:rgba(219,231,255,.92);font-weight:600}

  .rightstack{display:flex; gap:10px; align-items:flex-start;}
  .panel{padding:12px 14px; min-width:220px;}
  .hdr{
    font-family:var(--mono); font-size:11px; text-transform:uppercase;
    color:rgba(219,231,255,.82);
    display:flex; justify-content:space-between; margin-bottom:10px;
  }
  .kv{
    display:grid; grid-template-columns:1fr auto; gap:8px 14px; align-items:center;
    font-size:12.5px;
  }
  .k{color:var(--dim); font-family:var(--mono); font-size:11px; text-transform:uppercase; letter-spacing:.5px;}
  .v{color:rgba(219,231,255,.94); font-family:var(--mono); font-size:12px; font-variant-numeric: tabular-nums;}

  .bottom{
    position:absolute; left:18px; right:18px; bottom:16px;
    display:flex; justify-content:space-between; gap:12px; align-items:flex-end;
  }
  .help{
    padding:10px 12px; max-width:min(760px,70vw);
    display:flex; flex-wrap:wrap; gap:10px 12px; align-items:center;
    color:var(--muted); font-size:12.5px;
  }
  .key{
    font-family:var(--mono); font-size:11px; padding:3px 8px;
    border-radius:10px; border:1px solid rgba(219,231,255,.20);
    color:rgba(219,231,255,.86); background:rgba(10,16,30,.16);
  }
  .status{padding:12px 14px; min-width:320px;}
  .big{
    font-family:var(--mono); font-size:12px; text-transform:uppercase; letter-spacing:.6px;
    display:flex; justify-content:space-between; gap:10px; margin-bottom:8px;
    color:rgba(219,231,255,.92);
  }
  .bar{
    height:8px; border-radius:999px; background:rgba(219,231,255,.10);
    border:1px solid rgba(219,231,255,.14); overflow:hidden; position:relative;
  }
  .fill{
    position:absolute; inset:0; width:50%;
    background:linear-gradient(90deg, rgba(140,220,255,.18), rgba(140,220,255,.78));
    box-shadow:0 0 20px rgba(140,220,255,.35);
  }

  /* monk: quieter, never invisible */
  body.monk #hud .glass{opacity:.62; filter:saturate(.85);}
  body.monk #hud .help{opacity:.35;}

  /* grain + vignette */
  #grain{
    position:fixed; inset:0; pointer-events:none; opacity:.06; mix-blend-mode: overlay;
    background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.85' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
    background-size:260px 260px;
  }
  #vignette{
    position:fixed; inset:-2px; pointer-events:none;
    background: radial-gradient(1200px 760px at 50% 40%, rgba(0,0,0,0) 0%, rgba(0,0,0,.25) 58%, rgba(0,0,0,.62) 100%);
  }

  @media (max-width: 980px){
    .panel{display:none;}
    .status{min-width:260px;}
    .brand{max-width:78vw;}
  }
</style>
</head>
<body class="monk">
<canvas id="c"></canvas>

<div id="hud" aria-hidden="true">
  <div class="topbar">
    <div class="brand glass">
      <div class="title"><span class="dot"></span> EMBERWING // HAVEN <span class="badge" id="modeBadge">MONK</span></div>
      <div class="subtitle">Mission: <b>forward flight, steady hands.</b> <span id="missionLine">ゆっくりと。今ここ。</span></div>
    </div>

    <div class="rightstack">
      <div class="panel glass">
        <div class="hdr"><span>NAV</span><span class="badge" id="navBadge">MONK</span></div>
        <div class="kv">
          <div class="k">HDG</div><div class="v" id="hdg">000</div>
          <div class="k">ALT</div><div class="v" id="alt">00000</div>
          <div class="k">SPD</div><div class="v" id="spd">000</div>
          <div class="k">BOOST</div><div class="v" id="bst">OFF</div>
        </div>
      </div>

      <div class="panel glass">
        <div class="hdr"><span>MISSION</span><span class="badge" id="msBadge">FLOW</span></div>
        <div class="kv">
          <div class="k">GATES</div><div class="v" id="gates">0</div>
          <div class="k">MISS</div><div class="v" id="miss">0</div>
          <div class="k">SCORE</div><div class="v" id="score">0000</div>
          <div class="k">RANGE</div><div class="v" id="range">—</div>
        </div>
      </div>
    </div>
  </div>

  <div class="bottom">
    <div class="help glass" id="help">
      <span class="key">↑/↓</span> pitch
      <span class="key">←/→</span> roll
      <span class="key">SPACE</span> boost
      <span class="key">CAPS</span> monk
      <span class="key">ENTER</span> HUD
    </div>

    <div class="status glass">
      <div class="big"><span>WATTAGE</span><span class="badge" id="wattBadge">STEADY</span></div>
      <div class="bar"><div class="fill" id="wattFill"></div></div>
      <div class="kv" style="margin-top:10px">
        <div class="k">SIGNAL</div><div class="v" id="signal">CLEAN</div>
        <div class="k">LOCK</div><div class="v" id="lock">FORWARD</div>
      </div>
    </div>
  </div>
</div>

<div id="grain"></div>
<div id="vignette"></div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  const $ = (id)=>document.getElementById(id);
  const ui = {
    modeBadge:$("modeBadge"), missionLine:$("missionLine"),
    navBadge:$("navBadge"), msBadge:$("msBadge"),
    hdg:$("hdg"), alt:$("alt"), spd:$("spd"), bst:$("bst"),
    gates:$("gates"), miss:$("miss"), score:$("score"), range:$("range"),
    wattFill:$("wattFill"), wattBadge:$("wattBadge"), signal:$("signal"), lock:$("lock"),
    hud: $("hud"), help: $("help")
  };

  const TAU = Math.PI*2;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const fmt3=(n)=>String(Math.round(((n%360)+360)%360)).padStart(3,"0");
  const fmtAlt=(n)=>String(Math.round(n)).padStart(5,"0");
  const fmtSpd=(n)=>String(Math.round(n)).padStart(3,"0");

  const S = {
    t:0, dt:0,
    monk:true, hudVisible:true,
    keys:new Set(),

    // flight
    pitch:0, roll:0,
    heading:0,
    altitude:38100,
    throttle:0.72,
    boost:false,
    speed:760,
    targetSpeed:760,

    // camera sway
    swayX:0, swayY:0,

    // mission
    gatesHit:0, gatesMiss:0, score:0,
    wattage:0.86, signalClean:1.0,

    // gentle real feel
    pitchRate:0, rollRate:0,
    wind:0
  };

  function resize(){
    canvas.width = innerWidth;
    canvas.height = innerHeight;
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  function onKey(e, down){
    const k=e.code;
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space","CapsLock","Enter"].includes(k)) e.preventDefault();
    if (down) S.keys.add(k); else S.keys.delete(k);
    if (k==="Space") S.boost = down;

    if (down && k==="CapsLock"){
      S.monk = !S.monk;
      document.body.classList.toggle("monk", S.monk);
      ui.modeBadge.textContent = S.monk ? "MONK" : "LIVE";
      ui.navBadge.textContent  = S.boost ? "BOOST" : (S.monk ? "MONK" : "NORM");
      ui.missionLine.textContent = S.monk ? "ゆっくりと。今ここ。" : "Ignition → Glide → Create.";
    }
    if (down && k==="Enter"){
      S.hudVisible = !S.hudVisible;
      ui.hud.style.display = S.hudVisible ? "block" : "none";
    }
  }
  addEventListener("keydown",(e)=>onKey(e,true),{passive:false});
  addEventListener("keyup",(e)=>onKey(e,false),{passive:false});

  // ---------- Atmosphere (Haven sky) ----------
  function drawSky(){
    const w=canvas.width, h=canvas.height;

    // pitch shifts horizon; roll tilts it
    const horizonY = h*0.53 + S.pitch*120;

    // serene gradient (clear, not muddy)
    const sky = ctx.createLinearGradient(0,0,0,h);
    sky.addColorStop(0.00, "#05070b");
    sky.addColorStop(0.16, "#071225");
    sky.addColorStop(0.42, "#13355f");
    sky.addColorStop(0.70, "#4f9ac6");
    sky.addColorStop(1.00, "#0a2343");
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,w,h);

    // painterly glow
    const glow = ctx.createRadialGradient(w*0.52,h*0.28,0, w*0.52,h*0.28, Math.max(w,h)*0.95);
    glow.addColorStop(0,"rgba(255,245,235,0.10)");
    glow.addColorStop(0.55,"rgba(185,235,255,0.08)");
    glow.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = glow;
    ctx.fillRect(0,0,w,h);

    // horizon band + line (tilted)
    ctx.save();
    ctx.translate(w*0.5, horizonY);
    ctx.rotate(-S.roll*0.62);

    const band = ctx.createLinearGradient(0,-80,0,140);
    band.addColorStop(0,"rgba(255,255,255,0)");
    band.addColorStop(0.45,"rgba(190,235,255,0.16)");
    band.addColorStop(0.62,"rgba(255,210,170,0.09)");
    band.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = band;
    ctx.fillRect(-w,-110,w*2,260);

    ctx.globalAlpha = 0.34;
    ctx.strokeStyle = "rgba(220,245,255,0.78)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-w,0); ctx.lineTo(w,0);
    ctx.stroke();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // ---------- Forward motion cues (NOT rain) ----------
  const flow=[];
  const FLOW=720;
  function initFlow(){
    flow.length=0;
    for (let i=0;i<FLOW;i++) flow.push({x:Math.random()*2-1,y:Math.random()*2-1,z:Math.random(),s:Math.random()*1.2+0.2});
  }
  initFlow();

  function drawFlow(dt, forward){
    const w=canvas.width, h=canvas.height;
    const cx=w*0.5, cy=h*0.46;                 // vanishing point
    const sp = 0.95 + forward*2.05;

    for (const f of flow){
      f.z -= dt*(0.92 + (1-f.z)*3.8)*sp;
      if (f.z<=0.02){ f.x=Math.random()*2-1; f.y=Math.random()*2-1; f.z=1; f.s=Math.random()*1.2+0.2; }

      const p = 0.23/(f.z+0.06);
      const x = cx + (f.x + S.swayX*0.0011) * w * p;
      const y = cy + (f.y + S.swayY*0.0011) * h * p;

      const dx = x - cx;
      const dy = y - cy;
      const L  = (18 + (1-f.z)*90) * sp * p;

      ctx.globalAlpha = (0.05 + (1-f.z)*0.22) * (S.monk?0.82:1);
      ctx.strokeStyle = "rgba(205,235,255,0.86)";
      ctx.lineWidth   = Math.max(1, f.s*(1-f.z)*1.5);

      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + dx*0.08*L, y + dy*0.08*L);
      ctx.stroke();
    }
    ctx.globalAlpha=1; ctx.lineWidth=1;
  }

  // ---------- Gates ----------
  const gates=[];
  let gateTimer=0;
  function spawnGate(){
    const spread = S.monk ? 0.54 : 0.74;
    gates.push({
      x:(Math.random()*2-1)*spread,
      y:(Math.random()*2-1)*spread*0.52,
      z: 2200 + Math.random()*1600,
      r: 0.24 + Math.random()*0.12,
      hit:false
    });
  }

  function updateGates(dt, forward){
    for (let i=gates.length-1;i>=0;i--){
      const g=gates[i];
      g.z -= dt*(forward*940 + 260);
      if (g.z < 120){
        if (!g.hit){
          S.gatesMiss++;
          S.wattage = clamp(S.wattage - 0.06, 0, 1);
          S.signalClean = clamp(S.signalClean - 0.08, 0, 1);
        }
        gates.splice(i,1);
      }
    }
    gateTimer += dt*(S.monk ? 0.95 : 1.0);
    if (gateTimer > 0.95){
      gateTimer = 0;
      if (gates.length < 4) spawnGate();
    }

    // "aim" at center: subtle control
    const aimX = clamp(S.roll*0.55 + S.wind*0.06, -1, 1);
    const aimY = clamp(-S.pitch*0.75, -1, 1);

    for (const g of gates){
      if (g.hit) continue;
      if (g.z < 520 && g.z > 200){
        const dx = aimX - g.x;
        const dy = aimY - g.y;
        if (Math.hypot(dx,dy) < g.r*0.78){
          g.hit = true;
          S.gatesHit++;
          S.score += 28 + Math.round(70 * S.signalClean);
          S.wattage = clamp(S.wattage + 0.03, 0, 1);
          S.signalClean = clamp(S.signalClean + 0.05, 0, 1);
        }
      }
    }
  }

  function drawGates(){
    const w=canvas.width, h=canvas.height;
    const cx=w*0.5, cy=h*0.46;
    for (const gt of gates){
      const p = 920/(gt.z+220);
      const x = cx + (gt.x + S.swayX*0.0007) * w * 0.56 * p;
      const y = cy + (gt.y + S.swayY*0.0007) * h * 0.46 * p;
      const r = Math.max(18, gt.r * Math.min(w,h) * 0.48 * p);

      const a = clamp(0.10 + (1400-gt.z)/1400*0.40, 0.10, 0.45) * (S.monk?0.82:1);
      ctx.globalAlpha = a;

      ctx.save();
      ctx.translate(x,y);
      ctx.globalCompositeOperation="lighter";

      const glow = ctx.createRadialGradient(0,0,r*0.65, 0,0,r*1.25);
      glow.addColorStop(0, "rgba(140,220,255,0)");
      glow.addColorStop(0.55,"rgba(140,220,255,0.26)");
      glow.addColorStop(1, "rgba(255,190,120,0)");
      ctx.fillStyle = glow;

      ctx.strokeStyle = gt.hit ? "rgba(120,255,190,0.82)" : "rgba(200,230,255,0.82)";
      ctx.lineWidth = Math.max(1, r*0.06);
      ctx.beginPath(); ctx.arc(0,0,r,0,TAU); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,r*1.12,0,TAU); ctx.fill();

      ctx.globalCompositeOperation="source-over";
      ctx.restore();

      ctx.globalAlpha = 1;
    }
  }

  // ---------- Instruments (clean attitude overlay) ----------
  function drawAttitude(){
    const w=canvas.width, h=canvas.height;
    const cx=w*0.5, cy=h*0.52;
    const radius = Math.min(w,h)*0.15;

    const pxPerDeg = radius*0.18;
    const pitchDeg = clamp(S.pitch * 18, -26, 26);
    const rollRad  = clamp(S.roll * 0.62, -0.85, 0.85);

    // pitch ladder rotates with roll; shifts with pitch
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(-rollRad);
    ctx.translate(0, pitchDeg * pxPerDeg);

    ctx.globalAlpha = S.monk ? 0.22 : 0.26;
    ctx.strokeStyle = "rgba(220,245,255,0.85)";
    ctx.fillStyle   = "rgba(220,245,255,0.85)";
    ctx.lineWidth = 1;

    for (let d=-25; d<=25; d+=5){
      if (d===0) continue;
      const y = -d * pxPerDeg;
      const len = (d%10===0) ? radius*0.88 : radius*0.60;
      ctx.beginPath();
      ctx.moveTo(-len, y);
      ctx.lineTo( len, y);
      ctx.stroke();

      if (d%10===0){
        ctx.globalAlpha = S.monk ? 0.18 : 0.22;
        ctx.font = "11px " + getComputedStyle(document.documentElement).getPropertyValue('--mono');
        ctx.textAlign="left"; ctx.textBaseline="middle";
        ctx.fillText(String(Math.abs(d)), len+8, y);
        ctx.textAlign="right";
        ctx.fillText(String(Math.abs(d)), -len-8, y);
        ctx.globalAlpha = S.monk ? 0.22 : 0.26;
      }
    }

    // zero line
    ctx.globalAlpha = S.monk ? 0.26 : 0.30;
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(-radius*0.92, 0);
    ctx.lineTo( radius*0.92, 0);
    ctx.stroke();
    ctx.restore();

    // fixed reference marks (center)
    ctx.globalAlpha = S.monk ? 0.22 : 0.26;
    ctx.strokeStyle = "rgba(220,245,255,0.85)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(cx-26, cy); ctx.lineTo(cx-6, cy);
    ctx.moveTo(cx+6,  cy); ctx.lineTo(cx+26, cy);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // ---------- Cockpit framing (NO plane) ----------
  function drawCockpit(){
    const w=canvas.width, h=canvas.height;

    // mild vibration (disciplined)
    const vib = (S.boost ? 0.9 : 0.25) + (S.speed/1200)*0.35;
    const shake = (0.7 - S.wattage)*0.8 + vib*0.25;
    const ox = Math.sin(S.t*16)*shake + S.swayX*0.02;
    const oy = Math.cos(S.t*18)*shake + S.swayY*0.02;

    // canopy vignette + frame suggestion
    ctx.save();
    ctx.translate(ox, oy);

    // canopy edges
    ctx.globalAlpha = 0.80;
    const v = ctx.createRadialGradient(w*0.5,h*0.48, Math.min(w,h)*0.20, w*0.5,h*0.55, Math.min(w,h)*0.98);
    v.addColorStop(0,"rgba(0,0,0,0)");
    v.addColorStop(0.58,"rgba(0,0,0,0)");
    v.addColorStop(1,"rgba(0,0,0,0.58)");
    ctx.fillStyle = v;
    ctx.fillRect(0,0,w,h);

    // subtle canopy rib lines
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "rgba(219,231,255,0.45)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(w*0.22, 0);
    ctx.quadraticCurveTo(w*0.34, h*0.18, w*0.38, h*0.46);
    ctx.moveTo(w*0.78, 0);
    ctx.quadraticCurveTo(w*0.66, h*0.18, w*0.62, h*0.46);
    ctx.stroke();

    // dash silhouette (heavy)
    ctx.globalAlpha = 0.98;
    ctx.fillStyle = "rgba(6,9,14,0.94)";
    ctx.beginPath();
    ctx.moveTo(0, h*0.78);
    ctx.quadraticCurveTo(w*0.5, h*0.62, w, h*0.78);
    ctx.lineTo(w, h);
    ctx.lineTo(0, h);
    ctx.closePath();
    ctx.fill();

    // dash edge highlight
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "rgba(219,231,255,0.78)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, h*0.78);
    ctx.quadraticCurveTo(w*0.5, h*0.62, w, h*0.78);
    ctx.stroke();

    // windshield glare (warm/cool)
    ctx.globalAlpha = 0.14;
    const g = ctx.createRadialGradient(w*0.64,h*0.18,0, w*0.64,h*0.18, Math.max(w,h)*0.62);
    g.addColorStop(0,"rgba(255,245,235,0.40)");
    g.addColorStop(0.3,"rgba(185,235,255,0.16)");
    g.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // ---------- Flight model (subtle hands, strong forward) ----------
  function updateFlight(dt){
    const up=S.keys.has("ArrowUp"), dn=S.keys.has("ArrowDown");
    const lf=S.keys.has("ArrowLeft"), rt=S.keys.has("ArrowRight");

    const calm = S.monk ? 0.88 : 1.0;
    const pIn = (up?1:0) + (dn?-1:0);
    const rIn = (rt?1:0) + (lf?-1:0);

    // tiny inertia to feel like surfaces
    const pitchTarget = pIn * 0.22 * calm;
    const rollTarget  = rIn * 0.34 * calm;

    S.pitchRate += (pitchTarget - S.pitch) * dt * 10.0;
    S.rollRate  += (rollTarget  - S.roll ) * dt * 10.0;
    S.pitchRate *= (1 - dt*5.2);
    S.rollRate  *= (1 - dt*5.2);

    S.pitch += S.pitchRate * dt * 6.0;
    S.roll  += S.rollRate  * dt * 6.0;

    // speed: always forward, boost is punchy
    const base=780, max=1040, boostAdd=S.boost?380:0;
    S.targetSpeed = base + (max-base)*S.throttle + boostAdd;
    const resp = S.boost ? 3.2 : 1.9;
    S.speed += (S.targetSpeed - S.speed) * dt * resp;

    // altitude + heading
    S.altitude += (S.pitch*2800 + (S.boost?220:0)) * dt;
    const turn = S.roll * (0.62 + (S.speed/1100)) * calm;
    S.heading += (turn*48) * dt;

    // wind drift (slow)
    S.wind = Math.sin(S.t*0.13) * 0.45;

    // camera sway is smaller than control deflection
    S.swayX = lerp(S.swayX, (S.roll*180 + S.wind*22), dt*2.4);
    S.swayY = lerp(S.swayY, (-S.pitch*220), dt*2.4);

    // meters
    const stress=(S.boost?0.35:0)+(Math.abs(S.roll)+Math.abs(S.pitch))*0.46;
    const recover=(S.monk?0.24:0.12);
    S.wattage = clamp(S.wattage + (recover-stress)*dt*0.34, 0,1);

    const steady = 1 - clamp(stress,0,1);
    S.signalClean = clamp(lerp(S.signalClean, steady, dt*0.60), 0,1);
  }

  function updateUI(){
    ui.hdg.textContent = fmt3(S.heading);
    ui.alt.textContent = fmtAlt(S.altitude);
    ui.spd.textContent = fmtSpd(S.speed);
    ui.bst.textContent = S.boost ? "ON" : "OFF";
    ui.navBadge.textContent = S.boost ? "BOOST" : (S.monk ? "MONK" : "NORM");

    ui.gates.textContent = String(S.gatesHit);
    ui.miss.textContent  = String(S.gatesMiss);
    ui.score.textContent = String(S.score).padStart(4,"0");

    let nearest=null;
    for (const g of gates){ if (!g.hit && (nearest===null || g.z<nearest)) nearest=g.z; }
    ui.range.textContent = nearest ? Math.round(nearest)+"m" : "—";

    ui.wattFill.style.width = Math.round(S.wattage*100) + "%";
    ui.wattBadge.textContent = S.wattage>0.75 ? "STEADY" : (S.wattage>0.4 ? "WORKING" : "LOW");
    ui.signal.textContent = S.signalClean>0.78 ? "CLEAN" : (S.signalClean>0.45 ? "NOISY" : "FRAY");
    ui.lock.textContent = "FORWARD";
    ui.msBadge.textContent = "FLOW";
  }

  // ---------- Loop ----------
  let last = performance.now();
  function tick(now){
    S.dt = Math.min(0.033, (now-last)/1000);
    last = now;
    S.t += S.dt;

    updateFlight(S.dt);

    const forward = clamp((S.speed/820) + (S.boost?0.78:0), 0.85, 2.70);
    updateGates(S.dt, forward);

    drawSky();
    drawFlow(S.dt, forward);
    drawGates();

    // overlay instruments + cockpit frame
    drawAttitude();
    drawCockpit();

    updateUI();
    requestAnimationFrame(tick);
  }

  // seed
  spawnGate(); spawnGate();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
