<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>EMBERWING // HAVEN — Fighter Pilot</title>
  <style>
    :root{
      --ink: rgba(236,246,255,.92);
      --muted: rgba(236,246,255,.62);
      --dim: rgba(236,246,255,.30);
      --line: rgba(236,246,255,.11);
      --line2: rgba(236,246,255,.07);
      --glass: rgba(10,14,18,.22);
      --glass2: rgba(10,14,18,.34);
      --accent: rgba(150,210,255,.92);
      --mint: rgba(170,240,210,.86);
      --amber: rgba(255,226,160,.82);
      --hot: rgba(255,120,120,.72);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; overflow:hidden;
      background:#060b10;
      color:var(--ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    #stage{position:fixed; inset:0}
    canvas{position:absolute; inset:0; width:100%; height:100%; display:block}

    /* soft cinematic veil */
    #veil{
      position:absolute; inset:0; pointer-events:none;
      background:
        radial-gradient(900px 600px at 50% 18%, rgba(255,255,255,.08) 0%, rgba(255,255,255,0) 60%),
        radial-gradient(1200px 900px at 50% 62%, rgba(0,0,0,0) 0%, rgba(0,0,0,.20) 58%, rgba(0,0,0,.42) 100%),
        linear-gradient(to bottom, rgba(0,0,0,.30) 0%, rgba(0,0,0,.06) 40%, rgba(0,0,0,.34) 100%);
      mix-blend-mode:multiply;
    }

    /* UI */
    .topbar{
      position:absolute; left:16px; right:16px; top:14px;
      display:flex; justify-content:space-between; gap:14px;
      pointer-events:none;
    }
    .brand{display:flex; flex-direction:column; gap:10px; min-width:340px}
    .brandRow{display:flex; align-items:center; gap:10px}
    .dot{
      width:8px; height:8px; border-radius:999px;
      background:rgba(255,255,255,.24);
      box-shadow:0 0 26px rgba(150,210,255,.20);
    }
    .title{letter-spacing:.18em; font-size:12px; opacity:.92; white-space:nowrap}
    .pill{
      display:inline-flex; align-items:center;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--line);
      background:rgba(10,14,18,.18);
      color:var(--muted);
      font-size:11px; letter-spacing:.14em; text-transform:uppercase;
    }
    .mission{
      max-width:680px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line2);
      background:linear-gradient(to bottom, rgba(10,14,18,.26), rgba(10,14,18,.10));
      box-shadow:0 18px 60px rgba(0,0,0,.24);
      color:rgba(236,246,255,.74);
      font-size:12px; line-height:1.35; letter-spacing:.04em;
      backdrop-filter: blur(10px);
    }
    .mission b{color:rgba(236,246,255,.92); font-weight:600}
    .mission .jp{opacity:.62}
    .mission .sub{margin-top:6px; opacity:.80; min-height:16px}

    .hudWrap{display:flex; gap:12px; align-items:flex-start; justify-content:flex-end}
    .panel{
      width:320px;
      border-radius:16px;
      border:1px solid var(--line2);
      background:linear-gradient(to bottom, rgba(10,14,18,.22), rgba(10,14,18,.10));
      box-shadow:0 18px 55px rgba(0,0,0,.24);
      backdrop-filter: blur(10px);
      padding:12px 12px 10px;
      transition: opacity .18s ease, transform .18s ease, filter .18s ease;
    }
    .panelHeader{display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; gap:10px}
    .label{font-size:11px; letter-spacing:.18em; text-transform:uppercase; opacity:.62}
    .mode{
      font-size:10px; letter-spacing:.18em; text-transform:uppercase;
      padding:5px 9px; border-radius:999px;
      border:1px solid var(--line);
      color:rgba(236,246,255,.62);
      background:rgba(10,14,18,.18);
    }
    .grid{display:grid; grid-template-columns:1fr 1fr; gap:8px 10px; font-size:12px}
    .k{opacity:.55; letter-spacing:.08em}
    .v{text-align:right; opacity:.92; letter-spacing:.06em}
    .divider{height:1px; margin:10px 0; background:linear-gradient(to right, rgba(236,246,255,0), var(--line), rgba(236,246,255,0))}

    .controls{
      position:absolute; left:16px; bottom:16px;
      display:flex; gap:8px; flex-wrap:wrap; max-width:900px;
      pointer-events:none; opacity:.74;
      transition: opacity .18s ease, transform .18s ease;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line2);
      background:rgba(10,14,18,.20);
      color:rgba(236,246,255,.62);
      font-size:11px; letter-spacing:.10em; text-transform:lowercase;
      backdrop-filter: blur(8px);
    }
    .key{
      padding:3px 8px; border-radius:8px;
      border:1px solid rgba(236,246,255,.12);
      background:rgba(255,255,255,.04);
      color:rgba(236,246,255,.84);
      font-size:10px; letter-spacing:.16em; text-transform:uppercase;
    }

    .wattage{
      position:absolute; right:16px; bottom:16px; width:390px;
      border-radius:16px;
      border:1px solid var(--line2);
      background:linear-gradient(to bottom, rgba(10,14,18,.22), rgba(10,14,18,.10));
      box-shadow:0 18px 55px rgba(0,0,0,.24);
      backdrop-filter: blur(10px);
      padding:12px; pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .wRow{display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; gap:10px}
    .bar{
      height:10px; border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(236,246,255,.10);
      overflow:hidden;
    }
    .fill{
      height:100%; width:50%; border-radius:999px;
      background:linear-gradient(90deg, rgba(150,210,255,.0), rgba(150,210,255,.62), rgba(170,240,210,.52));
      transition: width .12s ease;
    }
    .wGrid{display:grid; grid-template-columns:1fr 1fr; gap:8px 10px; margin-top:10px; font-size:12px}

    /* Compelling center: velocity vector + flight path brackets (not the boring dot-cluster) */
    .reticle{
      position:absolute; left:50%; top:54%;
      width:560px; height:340px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      opacity:.26;
      filter: drop-shadow(0 14px 28px rgba(0,0,0,.22));
      transition: opacity .15s ease, transform .15s ease, filter .15s ease;
    }
    .reticle .h{
      position:absolute; left:0; right:0; top:50%;
      height:1px;
      background:linear-gradient(to right, rgba(236,246,255,0), rgba(236,246,255,.18), rgba(236,246,255,0));
    }
    .reticle .ring{
      position:absolute; left:50%; top:50%;
      width:86px; height:86px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      border:1px solid rgba(236,246,255,.20);
      box-shadow:0 0 0 1px rgba(236,246,255,.06) inset;
    }
    .reticle .pip{
      position:absolute; left:50%; top:50%;
      width:6px; height:6px;
      transform:translate(-50%,-50%);
      border-radius:99px;
      background:rgba(236,246,255,.22);
      box-shadow:0 0 0 14px rgba(236,246,255,.03);
    }
    .reticle .br{
      position:absolute; left:50%; top:50%;
      width:180px; height:120px;
      transform:translate(-50%,-50%);
      opacity:.85;
    }
    .br:before,.br:after{
      content:""; position:absolute; top:0; bottom:0; width:18px;
      border-top:1px solid rgba(236,246,255,.18);
      border-bottom:1px solid rgba(236,246,255,.18);
    }
    .br:before{left:0; border-left:1px solid rgba(236,246,255,.18)}
    .br:after{right:0; border-right:1px solid rgba(236,246,255,.18)}
    .reticle .vv{
      position:absolute; left:50%; top:50%;
      width:16px; height:16px;
      transform:translate(-50%,-50%);
      border-radius:99px;
      border:1px solid rgba(170,240,210,.22);
      box-shadow:0 0 26px rgba(170,240,210,.08);
    }

    /* lock + fighter bite */
    .lock-on .reticle{
      opacity:.40;
      transform:translate(-50%,-50%) scale(1.02);
      filter: drop-shadow(0 18px 34px rgba(0,0,0,.28));
    }
    .lock-on .reticle .ring{border-color: rgba(170,240,210,.34)}
    .lock-on .reticle .vv{border-color: rgba(255,226,160,.28)}
    .lock-on .reticle .h{
      background:linear-gradient(to right, rgba(236,246,255,0), rgba(170,240,210,.22), rgba(236,246,255,0));
    }

    .hudHidden .panel,
    .hudHidden .wattage,
    .hudHidden .controls{
      opacity:0; transform:translateY(6px);
    }

    /* subtle “warp syrup” breathing of HUD in monk */
    .monk-breathe .panel,
    .monk-breathe .wattage{
      animation: breathe 1.35s ease-in-out infinite;
    }
    @keyframes breathe{
      0%{filter:brightness(1); transform:translateY(0)}
      50%{filter:brightness(1.05); transform:translateY(-1px)}
      100%{filter:brightness(1); transform:translateY(0)}
    }

    @media (max-width: 980px){
      .hudWrap{display:none}
      .mission{max-width:84vw}
      .wattage{width:min(410px, calc(100vw - 32px))}
      .reticle{opacity:.18}
    }
  </style>
</head>
<body>
<div id="stage">
  <canvas id="scene"></canvas>
  <div id="veil"></div>

  <div class="topbar">
    <div class="brand">
      <div class="brandRow">
        <div class="dot"></div>
        <div class="title">EMBERWING // HAVEN</div>
        <div class="pill" id="pillMode">FIGHTER</div>
      </div>
      <div class="mission" id="missionBox">
        <b>Mission:</b> warp-speed glide, syrup control, perfect lines. <span class="jp">ゆっくりと。今ここ。</span>
        <div class="sub" id="missionSub"></div>
      </div>
    </div>

    <div class="hudWrap">
      <div class="panel">
        <div class="panelHeader">
          <div class="label">NAV</div>
          <div class="mode" id="modeTag">FIGHTER</div>
        </div>
        <div class="grid">
          <div class="k">HDG</div><div class="v" id="hdg">000</div>
          <div class="k">ALT</div><div class="v" id="alt">00000</div>
          <div class="k">SPD</div><div class="v" id="spd">000</div>
          <div class="k">WARP</div><div class="v" id="warp">OFF</div>
        </div>
        <div class="divider"></div>
        <div class="grid">
          <div class="k">PITCH</div><div class="v" id="pitch">0.0</div>
          <div class="k">ROLL</div><div class="v" id="roll">0.0</div>
        </div>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <div class="label">RUN</div>
          <div class="mode" id="stabilityTag">ACCURATE</div>
        </div>
        <div class="grid">
          <div class="k">GATES</div><div class="v" id="gates">0</div>
          <div class="k">MISS</div><div class="v" id="miss">0</div>
          <div class="k">SCORE</div><div class="v" id="score">0000</div>
          <div class="k">RANGE</div><div class="v" id="range">0.0km</div>
        </div>
        <div class="divider"></div>
        <div class="grid">
          <div class="k">COMBO</div><div class="v" id="combo">x1</div>
          <div class="k">LOCK</div><div class="v" id="lock">FORWARD</div>
        </div>
      </div>
    </div>
  </div>

  <div class="reticle" id="reticle">
    <div class="h"></div>
    <div class="ring"></div>
    <div class="pip"></div>
    <div class="br"></div>
    <div class="vv" id="vv"></div>
  </div>

  <div class="controls">
    <div class="chip"><span class="key">↑</span> pull (pitch up)</div>
    <div class="chip"><span class="key">↓</span> push (pitch down)</div>
    <div class="chip"><span class="key">←/→</span> roll</div>
    <div class="chip"><span class="key">space</span> warp</div>
    <div class="chip"><span class="key">f</span> fighter/monk</div>
    <div class="chip"><span class="key">enter</span> hud</div>
  </div>

  <div class="wattage">
    <div class="wRow">
      <div class="label">WATTAGE</div>
      <div class="mode" id="wState">CLEAN</div>
    </div>
    <div class="bar"><div class="fill" id="wFill"></div></div>
    <div class="wGrid">
      <div class="k">SIGNAL</div><div class="v" id="signal">CLEAR</div>
      <div class="k">STATE</div><div class="v" id="stateTag">LOCKED</div>
    </div>
  </div>
</div>

<script>
(() => {
  const c = document.getElementById("scene");
  const ctx = c.getContext("2d", { alpha:false });

  const DPR = () => Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W=0,H=0,dpr=1;
  function resize(){
    dpr = DPR();
    W = innerWidth|0; H = innerHeight|0;
    c.width = (W*dpr)|0; c.height = (H*dpr)|0;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = true;
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const smooth=t=>t*t*(3-2*t);
  const rnd=(a=1)=>Math.random()*a;
  const easeTo=(v,target,k,dt)=>v + (target-v)*(1-Math.exp(-k*dt));

  // hash noise
  function hash(x,y){
    let n = x*374761393 + y*668265263;
    n = (n^(n>>>13)) * 1274126177;
    n = n^(n>>>16);
    return (n>>>0)/4294967295;
  }
  function noise(x,y){
    const xi=Math.floor(x), yi=Math.floor(y);
    const xf=x-xi, yf=y-yi;
    const v00=hash(xi,yi), v10=hash(xi+1,yi), v01=hash(xi,yi+1), v11=hash(xi+1,yi+1);
    const u=smooth(xf), v=smooth(yf);
    return lerp(lerp(v00,v10,u), lerp(v01,v11,u), v);
  }
  function fbm(x,y){
    let v=0,a=0.55,f=1.0;
    for(let i=0;i<6;i++){ v += a*noise(x*f,y*f); f*=2; a*=0.5; }
    return v;
  }

  // UI
  const $ = (id)=>document.getElementById(id);
  const ui={
    pillMode:$("pillMode"), modeTag:$("modeTag"), stabilityTag:$("stabilityTag"),
    hdg:$("hdg"), alt:$("alt"), spd:$("spd"), warp:$("warp"),
    pitch:$("pitch"), roll:$("roll"),
    gates:$("gates"), miss:$("miss"), score:$("score"), range:$("range"), combo:$("combo"), lock:$("lock"),
    wFill:$("wFill"), wState:$("wState"), signal:$("signal"), stateTag:$("stateTag"),
    missionSub:$("missionSub"), missionBox:$("missionBox"),
    vv:$("vv"),
  };
  const fmt3=n=>String(Math.round(n)).padStart(3,"0");
  const fmt5=n=>String(Math.round(n)).padStart(5,"0");
  function whisper(text,ms=1200){
    ui.missionSub.textContent=text;
    clearTimeout(whisper._t);
    whisper._t=setTimeout(()=>ui.missionSub.textContent="",ms);
  }
  function pulse(el){
    el.classList.remove("pulse"); void el.offsetWidth; el.classList.add("pulse");
  }

  // INPUT (FIXED: aviation feel — Up = pull = pitch up)
  const keys=new Set();
  addEventListener("keydown",(e)=>{
    if(e.code==="Enter"){
      state.hud=!state.hud;
      document.body.classList.toggle("hudHidden", !state.hud);
    }
    if(e.code==="KeyF"){
      state.fighter = !state.fighter;
      state.monk = !state.fighter;
      applyMode();
    }
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
  },{passive:false});
  addEventListener("keyup",(e)=>keys.delete(e.code),{passive:true});

  // WORLD
  const state={
    t:0,
    // physics state (actual)
    pitch:0, roll:0,
    // desired (from input) for syrup control
    pitchCmd:0, rollCmd:0,

    hdg:352, alt:38200,
    spd:220,
    warpOn:false,

    monk:false,
    fighter:true,
    hud:true,

    range:0,
    score:0,
    combo:1,
    gatesHit:0,
    miss:0,

    wattage:0.78,
    hitGlow:0,

    lockStrength:0,
    _lockWhispered:false,

    // warp lines
    streaks:[],
    // stars
    stars:[],
    // gates
    gates:[],
    gateSpawn:0
  };

  function applyMode(){
    if(state.fighter){
      ui.pillMode.textContent="FIGHTER";
      ui.modeTag.textContent="FIGHTER";
      ui.stabilityTag.textContent="ACCURATE";
      ui.stateTag.textContent="LOCKED";
      document.body.classList.remove("monk-breathe");
      whisper("Fighter engaged: accuracy is final.", 1500);
    }else{
      ui.pillMode.textContent="MONK";
      ui.modeTag.textContent="FLOW";
      ui.stabilityTag.textContent="STEADY";
      ui.stateTag.textContent="GLIDE";
      document.body.classList.add("monk-breathe");
      whisper("Monk engaged: soften. glide. listen.", 1500);
    }
    pulse(ui.missionBox); pulse(ui.pillMode);
  }
  applyMode();

  // Stars: calm base + warp streak overlay
  function seedStars(){
    state.stars.length=0;
    const n=240;
    for(let i=0;i<n;i++){
      state.stars.push({
        x:rnd(), y:rnd(),
        z:0.15+rnd(0.85),
        tw:rnd(1000),
      });
    }
  }
  function seedStreaks(){
    state.streaks.length=0;
    const n=220;
    for(let i=0;i<n;i++){
      const a = rnd(Math.PI*2);
      const r = Math.pow(rnd(), 0.55); // concentrate toward edges
      state.streaks.push({
        a, r,
        p:rnd(1000),
        w:0.6+rnd(1.6)
      });
    }
  }
  seedStars(); seedStreaks();

  function spawnGate(){
    // tighter, more “flight-test” placement — feels intentional, not random confetti
    const centerBias = state.fighter ? 0.12 : 0.18;
    const x = 0.50 + (rnd()-0.5)*centerBias*2;
    const y = 0.54 + (rnd()-0.5)*(state.fighter ? 0.12 : 0.16);
    const r = state.fighter ? (0.060 + rnd(0.012)) : (0.068 + rnd(0.016));
    const z = 1.35 + rnd(0.55);
    state.gates.push({x,y,r,z,alive:true,missed:false,hit:false});
  }
  for(let i=0;i<3;i++) spawnGate();

  function nearestGateInfo(){
    const cx = 0.50 + state.roll*0.030;
    const cy = 0.54 + state.pitch*0.024;

    let best=null, bestScore=1e9;
    for(const g of state.gates){
      if(!g.alive || g.hit) continue;
      if(g.z>0.98 || g.z<0.30) continue;
      const d=Math.hypot(g.x-cx,g.y-cy);
      const w=d*(0.55+g.z*0.75);
      if(w<bestScore){bestScore=w; best=g;}
    }
    if(!best) return {g:null,cx,cy,dist:999};
    return {g:best,cx,cy,dist:Math.hypot(best.x-cx,best.y-cy)};
  }

  // RENDER — calm sky + austere land + WARPTUNNEL overlay (compelling center)
  function drawSky(hy){
    const g=ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0.00,"#050b11");
    g.addColorStop(0.18,"#071625");
    g.addColorStop(0.42,"#0f2c45");
    g.addColorStop(0.68,"#2d6e92");
    g.addColorStop(0.86,"#9fcee6");
    g.addColorStop(1.00,"#e7f6ff");
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    const cx=W*0.62, cy=H*0.22, r=Math.min(W,H)*0.75;
    const rg=ctx.createRadialGradient(cx,cy,0,cx,cy,r);
    rg.addColorStop(0,"rgba(255,255,255,0.18)");
    rg.addColorStop(0.45,"rgba(255,255,255,0.07)");
    rg.addColorStop(1,"rgba(255,255,255,0)");
    ctx.fillStyle=rg; ctx.fillRect(0,0,W,H);

    // very subtle aurora band
    const a = state.monk ? 0.08 : 0.10;
    const ay = H*0.22 + Math.sin(state.t*0.12)*16;
    const ag = ctx.createLinearGradient(0, ay, 0, ay+H*0.34);
    ag.addColorStop(0, `rgba(160,220,255,${a*0.0})`);
    ag.addColorStop(0.35, `rgba(160,220,255,${a*0.75})`);
    ag.addColorStop(0.70, `rgba(185,255,220,${a*0.55})`);
    ag.addColorStop(1, `rgba(160,220,255,${a*0.0})`);
    ctx.globalCompositeOperation="screen";
    ctx.fillStyle=ag; ctx.fillRect(0,ay,W,H*0.40);
    ctx.globalCompositeOperation="source-over";

    const mist=ctx.createLinearGradient(0,hy-85,0,hy+125);
    mist.addColorStop(0,"rgba(255,255,255,0)");
    mist.addColorStop(0.42,"rgba(255,255,255,0.12)");
    mist.addColorStop(1,"rgba(255,255,255,0)");
    ctx.fillStyle=mist; ctx.fillRect(0,hy-85,W,220);
  }

  function drawStars(hy){
    ctx.globalCompositeOperation="screen";
    for(const s of state.stars){
      const drift = state.range*0.0008*(0.5+s.z);
      const tw = 0.65 + 0.35*Math.sin(state.t*0.9 + s.tw);
      const x = ((s.x + drift) % 1) * W;
      const y = (s.y * (hy*0.98)) + 6;
      const a = (0.05 + 0.10*s.z) * tw * (state.warpOn ? 0.55 : 1.0);
      if(a<0.01) continue;
      ctx.fillStyle = `rgba(210,240,255,${a})`;
      ctx.fillRect(x,y,1,1);
    }
    ctx.globalCompositeOperation="source-over";
  }

  function drawWarpTunnel(){
    // “warp speed yet syrup”: fast visuals, stable center, low nausea
    // Streaks radiate outward but DO NOT rotate wildly.
    const centerX = W*0.5 + state.roll*W*0.010;
    const centerY = H*0.54 + state.pitch*H*0.008;

    const spdN = clamp(state.spd/420, 0, 1);
    const warp = state.warpOn ? 1 : 0;
    const intensity = clamp(0.18 + spdN*0.28 + warp*0.45, 0, 0.95);

    if(intensity <= 0.001) return;

    ctx.save();
    ctx.globalCompositeOperation="screen";

    // soft vignette glow “tunnel mouth”
    const r = Math.min(W,H)*0.55;
    const g = ctx.createRadialGradient(centerX,centerY, r*0.06, centerX,centerY, r);
    g.addColorStop(0, `rgba(170,240,210,${0.06*intensity})`);
    g.addColorStop(0.35, `rgba(150,210,255,${0.05*intensity})`);
    g.addColorStop(1, `rgba(150,210,255,0)`);
    ctx.fillStyle=g; ctx.fillRect(centerX-r,centerY-r,r*2,r*2);

    // streaks
    ctx.lineCap="round";
    for(const st of state.streaks){
      const a = st.a;
      const edge = Math.pow(st.r, 0.85);

      // base radius: favors edges for drama, center stays calm
      const baseR = edge * Math.min(W,H) * 0.70;

      // length grows with speed, but eased to keep “syrup”
      const L = (22 + 220*intensity) * (0.65 + 0.6*edge) * (state.fighter ? 1.0 : 0.85);

      const x1 = centerX + Math.cos(a)*baseR;
      const y1 = centerY + Math.sin(a)*baseR;
      const x2 = centerX + Math.cos(a)*(baseR + L);
      const y2 = centerY + Math.sin(a)*(baseR + L);

      const alpha = (0.015 + 0.085*intensity) * (0.25 + 0.75*edge);
      const w = (0.6 + st.w) * (0.65 + 0.9*intensity);

      ctx.strokeStyle = `rgba(170,240,210,${alpha})`;
      ctx.lineWidth = w;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }

    ctx.restore();
  }

  function drawCloudVeil(hy){
    // minimal cloud texture (austere) — no nausea “moving carpet”
    const step = 7;
    const top = hy - H*0.52;
    const bot = hy + H*0.06;

    for(let y=top; y<bot; y+=step){
      const yn=y/H;
      const band = clamp((yn - (hy/H - 0.50))*1.35, 0, 1);
      const b=band*band;

      for(let x=0; x<W; x+=step){
        const n = fbm((x + state.range*120)*0.0016, (y + state.t*18)*0.0012);
        const v = clamp((n-0.52)*2.1, 0, 1);
        const a = 0.10 * v*v*(3-2*v) * b * (state.monk ? 1.15 : 1.0);
        if(a<0.004) continue;
        ctx.fillStyle = `rgba(245,252,255,${a})`;
        ctx.fillRect(x,y,step,step);
      }
    }
  }

  function drawLand(hy){
    const tilt = state.roll * 0.030;
    ctx.save();
    ctx.translate(W/2,hy);
    ctx.rotate(tilt);
    ctx.translate(-W/2,-hy);

    const layers=[
      {dy:26,a:0.22,amp:30,s:0.0036},
      {dy:42,a:0.28,amp:38,s:0.0032},
      {dy:60,a:0.34,amp:46,s:0.0028}
    ];
    for(let li=0; li<layers.length; li++){
      const L=layers[li];
      ctx.fillStyle=`rgba(0,0,0,${0.56+li*0.08})`;
      ctx.beginPath();
      const yBase=hy+L.dy;
      ctx.moveTo(-40,yBase);
      const steps=70;
      for(let i=0;i<=steps;i++){
        const x=(i/steps)*(W+80)-40;
        const n=fbm((x+state.range*180*(1+li*0.18))*L.s, 8.0+li*2.7);
        const yy=yBase+(n-0.5)*L.amp;
        ctx.lineTo(x,yy);
      }
      ctx.lineTo(W+40,H+60);
      ctx.lineTo(-40,H+60);
      ctx.closePath();
      ctx.globalAlpha=L.a; ctx.fill(); ctx.globalAlpha=1;
    }
    ctx.restore();

    // cockpit shadow curve (keeps “pilot” feeling)
    const g=ctx.createLinearGradient(0,hy+40,0,H);
    g.addColorStop(0,"rgba(0,0,0,0.18)");
    g.addColorStop(0.40,"rgba(0,0,0,0.58)");
    g.addColorStop(1,"rgba(0,0,0,0.88)");
    ctx.fillStyle=g;
    ctx.beginPath();
    const curve=H*0.12;
    ctx.moveTo(0,H);
    ctx.quadraticCurveTo(W*0.5, hy+curve, W, H);
    ctx.closePath();
    ctx.fill();
  }

  function drawGates(){
    const centerX=W*0.5, centerY=H*0.54;

    // global “hit” bloom
    if(state.hitGlow>0.001){
      ctx.globalCompositeOperation="screen";
      const a=state.hitGlow*0.20;
      const g=ctx.createRadialGradient(centerX,centerY,0,centerX,centerY,Math.min(W,H)*0.46);
      g.addColorStop(0,`rgba(170,240,210,${a})`);
      g.addColorStop(0.55,`rgba(150,210,255,${a*0.55})`);
      g.addColorStop(1,`rgba(150,210,255,0)`);
      ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      ctx.globalCompositeOperation="source-over";
    }

    for(const gt of state.gates){
      if(!gt.alive) continue;

      const z=gt.z;
      const px=lerp(centerX, gt.x*W, 1/(z));
      const py=lerp(centerY, gt.y*H, 1/(z));
      const pr=(gt.r*Math.min(W,H))*(1/(z));
      if(pr<4) continue;

      const alpha=clamp((1.35-z),0,1);
      const bite = state.fighter ? 0.88 : 0.66;

      ctx.save();
      ctx.globalCompositeOperation="screen";

      // “aperture gate”: outer + inner + subtle chevrons
      ctx.lineWidth=Math.max(2, pr*0.030);
      ctx.strokeStyle=`rgba(150,210,255,${alpha*0.42*bite})`;
      ctx.beginPath(); ctx.arc(px,py,pr,0,Math.PI*2); ctx.stroke();

      ctx.lineWidth=Math.max(1.5, pr*0.018);
      ctx.strokeStyle=`rgba(170,240,210,${alpha*0.38*bite})`;
      ctx.beginPath(); ctx.arc(px,py,pr*0.78,0,Math.PI*2); ctx.stroke();

      const haze=ctx.createRadialGradient(px,py,pr*0.2,px,py,pr*1.35);
      haze.addColorStop(0,`rgba(255,226,160,${alpha*0.08*bite})`);
      haze.addColorStop(0.55,`rgba(170,240,210,${alpha*0.07*bite})`);
      haze.addColorStop(1,`rgba(150,210,255,0)`);
      ctx.fillStyle=haze;
      ctx.beginPath(); ctx.arc(px,py,pr*1.35,0,Math.PI*2); ctx.fill();

      // chevrons (directionality = “pilot”)
      ctx.globalAlpha = alpha*0.22*bite;
      ctx.strokeStyle="rgba(255,226,160,0.8)";
      ctx.lineWidth=1;
      for(let i=0;i<6;i++){
        const ang = (i/6)*Math.PI*2;
        const r0 = pr*0.86, r1=pr*1.05;
        ctx.beginPath();
        ctx.moveTo(px+Math.cos(ang)*r0, py+Math.sin(ang)*r0);
        ctx.lineTo(px+Math.cos(ang)*r1, py+Math.sin(ang)*r1);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      ctx.restore();

      if(gt.missed){
        ctx.globalAlpha=0.28;
        ctx.strokeStyle="rgba(255,120,120,0.22)";
        ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(px,py,pr*1.08,0,Math.PI*2); ctx.stroke();
        ctx.globalAlpha=1;
      }
    }
  }

  // UPDATE UI + VV (velocity vector) placement
  function updateUI(){
    ui.hdg.textContent = fmt3(((state.hdg%360)+360)%360);
    ui.alt.textContent = fmt5(state.alt);
    ui.spd.textContent = fmt3(state.spd);
    ui.warp.textContent = state.warpOn ? "ON" : "OFF";
    ui.pitch.textContent = (state.pitch*6).toFixed(1);
    ui.roll.textContent  = (state.roll*12).toFixed(1);

    ui.gates.textContent = state.gatesHit;
    ui.miss.textContent  = state.miss;
    ui.score.textContent = String(state.score).padStart(4,"0");
    ui.range.textContent = state.range.toFixed(1)+"km";
    ui.combo.textContent = "x"+state.combo;

    const clean = state.wattage>0.62;
    ui.wFill.style.width = (state.wattage*100).toFixed(0)+"%";
    ui.wState.textContent = clean ? "CLEAN" : "THIN";
    ui.signal.textContent = clean ? "CLEAR" : "NOISY";
    ui.lock.textContent = state.lockStrength>0.35 ? "GATE" : "FORWARD";

    // VV moves slightly with “drift” but remains stable (no nausea)
    const vx = (state.roll*0.030) * 280;   // px within reticle box
    const vy = (state.pitch*0.024) * 240;
    ui.vv.style.transform = `translate(calc(-50% + ${vx}px), calc(-50% + ${vy}px))`;
  }

  // SIM
  function step(dt){
    state.t += dt;

    // MODE parameters: warp-speed visuals, syrup control, accuracy final
    const fighter = state.fighter;
    const monk = !fighter;

    // INPUT (fixed + accurate)
    // Up = pull = pitch up (positive), Down = pitch down (negative)
    const pitchIn = (keys.has("ArrowUp") ? 1 : 0) + (keys.has("ArrowDown") ? -1 : 0);
    const rollIn  = (keys.has("ArrowRight") ? 1 : 0) + (keys.has("ArrowLeft") ? -1 : 0);
    state.warpOn = keys.has("Space");

    // Command shaping (deadzone + smoothing)
    const dead = 0.06;
    const targetPitchCmd = Math.abs(pitchIn) < dead ? 0 : pitchIn;
    const targetRollCmd  = Math.abs(rollIn)  < dead ? 0 : rollIn;

    state.pitchCmd = easeTo(state.pitchCmd, targetPitchCmd, fighter ? 18 : 10, dt);
    state.rollCmd  = easeTo(state.rollCmd,  targetRollCmd,  fighter ? 18 : 10, dt);

    // Syrup dynamics: spring-damper, critically damped-ish
    // Fighter: faster response, still smooth. Monk: slower, floatier.
    const k = fighter ? 16.0 : 8.5;   // stiffness
    const d = fighter ? 8.8  : 6.6;   // damping
    // integrate “rate”
    state.pitchRate = (state.pitchRate||0);
    state.rollRate  = (state.rollRate||0);

    const pitchErr = state.pitchCmd - state.pitch;
    const rollErr  = state.rollCmd  - state.roll;

    state.pitchRate += (pitchErr*k - state.pitchRate*d) * dt;
    state.rollRate  += (rollErr*k  - state.rollRate*d)  * dt;

    // clamp rates for comfort
    const rateMax = fighter ? 3.0 : 1.8;
    state.pitchRate = clamp(state.pitchRate, -rateMax, rateMax);
    state.rollRate  = clamp(state.rollRate,  -rateMax, rateMax);

    state.pitch += state.pitchRate * dt;
    state.roll  += state.rollRate  * dt;

    state.pitch = clamp(state.pitch, -1, 1);
    state.roll  = clamp(state.roll,  -1, 1);

    // SPEED: warp-speed feel, but stable handling
    const base = fighter ? 260 : 210;
    const warpAdd = state.warpOn ? (fighter ? 210 : 170) : 0;
    const targetSpd = base + warpAdd;
    state.spd = Math.round(state.spd + (targetSpd - state.spd) * (fighter ? 0.10 : 0.07));

    // NAV
    state.hdg += state.roll * (fighter ? 0.55 : 0.28);
    state.alt = Math.round(state.alt + (state.pitch) * (fighter ? 10 : 5)); // pull-up increases altitude

    const forward = (state.spd/260) * (state.warpOn ? 1.25 : 1.0);
    state.range += forward * dt * 0.090;
    state.score += Math.floor(forward * dt * (fighter ? 1.00 : 0.60));
    state.hitGlow = Math.max(0, state.hitGlow - dt*1.8);

    // Wattage: fighter burns more under warp + aggressive input
    let w = state.wattage;
    w += (monk ? 0.0009 : -0.00035) * (dt*60);
    if(state.warpOn) w -= (fighter ? 0.0015 : 0.0011) * (dt*60);
    if(fighter && (Math.abs(pitchIn)+Math.abs(rollIn))>0) w -= 0.0006*(dt*60);
    state.wattage = clamp(w, 0.18, 0.96);

    // Gates: disciplined rhythm
    state.gateSpawn -= dt;
    const spawnEvery = fighter ? 0.95 : 1.30;
    if(state.gateSpawn <= 0){
      spawnGate();
      state.gateSpawn = spawnEvery;
    }

    // Gate lock + “accuracy final” assist (fighter: less assist)
    const info = nearestGateInfo();
    const g = info.g;

    let targetLock = 0;
    if(g){
      const tol = g.r * (fighter ? 0.95 : 1.18);
      targetLock = clamp(1 - (info.dist / tol), 0, 1);
      targetLock *= clamp((0.92 - g.z)/0.58, 0, 1);
    }
    state.lockStrength = easeTo(state.lockStrength, targetLock, 12.0, dt);

    if(state.lockStrength > 0.22) document.body.classList.add("lock-on");
    else document.body.classList.remove("lock-on");

    // micro-assist: monk gets more, fighter gets tiny
    if(g && state.lockStrength > 0.18){
      const cx = 0.50 + state.roll*0.030;
      const cy = 0.54 + state.pitch*0.024;
      const dx = g.x - cx;
      const dy = g.y - cy;

      const assist = (fighter ? 0.18 : 0.55) * state.lockStrength;
      state.roll  = clamp(state.roll  + (dx * 0.50) * assist, -1, 1);
      state.pitch = clamp(state.pitch + (dy * 0.42) * assist, -1, 1);

      if(state.lockStrength > 0.62 && !state._lockWhispered){
        state._lockWhispered = true;
        whisper("Lock: hold the line.", 1000);
        pulse(ui.missionBox);
      }
      if(state.lockStrength < 0.26) state._lockWhispered = false;
    } else {
      state._lockWhispered = false;
    }

    // Update gates + hit/miss
    const aimX = 0.50 + state.roll*0.030;
    const aimY = 0.54 + state.pitch*0.024;

    for(const gt of state.gates){
      if(!gt.alive) continue;

      const zSpeed = (fighter ? 0.95 : 0.62) * forward;
      gt.z -= dt * zSpeed;

      if(!gt.missed && gt.z < 0.50){
        gt.missed = true;
        state.miss += 1;
        state.combo = 1;
        whisper("Miss. Reset. Fly true.", 1100);
        pulse(ui.missionBox);
      }
      if(gt.z < 0.18) gt.alive = false;

      if(gt.alive && !gt.hit && gt.z < 0.64 && gt.z > 0.30){
        const dist = Math.hypot(gt.x-aimX, gt.y-aimY);
        const tol = gt.r * (fighter ? 0.78 : 0.94); // fighter stricter
        if(dist < tol){
          gt.hit = true; gt.alive = false;
          state.gatesHit += 1;
          state.combo = Math.min(9, state.combo + 1);
          const bonus = Math.floor((fighter ? 70 : 45) * state.combo);
          state.score += bonus;
          state.hitGlow = Math.min(1, state.hitGlow + 0.95);
          pulse(ui.score); pulse(ui.combo);
          whisper(`Gate clean. +${bonus} (x${state.combo}).`, 1000);
        }
      }
    }

    if(state.gates.length > 34) state.gates = state.gates.filter(g=>g.alive);

    updateUI();
  }

  // LOOP
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    step(dt);

    // camera: syrup-stable (tiny motion only)
    const hy = H*(0.62 - state.pitch*0.018);
    const bob = (Math.sin(state.t*0.45)*4 + Math.sin(state.t*0.21)*3) * (state.monk ? 0.9 : 0.65);

    ctx.clearRect(0,0,W,H);
    ctx.save();
    ctx.translate(0, bob);

    drawSky(hy);
    drawStars(hy);
    drawCloudVeil(hy);
    drawWarpTunnel();
    drawLand(hy);
    drawGates();

    ctx.restore();

    requestAnimationFrame(loop);
  }

  whisper("Fighter pilot mode engaged. Accuracy is final.", 1700);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
