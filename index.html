<!-- PATCH: “Gate Lock” whisper + reticle snap + HUD breath
     Apply these edits to the last HTML I gave you.

1) ADD this CSS (near the bottom of <style>):
-->
<style>
  /* --- Gate Lock UI --- */
  .reticle{
    transition: transform .18s ease, opacity .18s ease, filter .18s ease;
    transform: translate(-50%,-50%) scale(1);
  }
  .lock-on .reticle{
    opacity:.30;
    filter: drop-shadow(0 18px 34px rgba(0,0,0,.28));
    transform: translate(-50%,-50%) scale(1.03);
  }
  .lock-on .reticle .c{
    border-color: rgba(170,240,210,.34);
    box-shadow:
      0 0 0 1px rgba(236,246,255,.06) inset,
      0 0 26px rgba(170,240,210,.14);
  }
  .lock-on .reticle .h{
    background: linear-gradient(to right, rgba(236,246,255,0), rgba(170,240,210,.26), rgba(236,246,255,0));
  }

  /* “HUD breath” */
  .hud-breathe .panel,
  .hud-breathe .wattage{
    animation: breathe 1.35s ease-in-out infinite;
  }
  @keyframes breathe{
    0%{filter:brightness(1); transform:translateY(0)}
    50%{filter:brightness(1.05); transform:translateY(-1px)}
    100%{filter:brightness(1); transform:translateY(0)}
  }
</style>

<script>
/*
2) ADD these helpers INSIDE your IIFE (same scope as state, updateUI, etc.)
   Place them near your other helper functions.
*/
const body = document.body;
let lockStrength = 0; // 0..1

function easeTo(v, target, k, dt){
  // stable exponential smoothing
  return v + (target - v) * (1 - Math.exp(-k * dt));
}

function nearestGateInfo(){
  // returns {g, dist, nx, ny} in normalized (0..1) space around reticle
  const cx = 0.50 + state.roll*0.030;
  const cy = 0.54 + state.pitch*0.024;

  let best = null;
  let bestD = 1e9;

  for(const g of state.gates){
    if(!g.alive || g.hit) continue;
    // only consider “approach window”
    if(g.z > 0.85 || g.z < 0.28) continue;

    const dx = g.x - cx;
    const dy = g.y - cy;
    const d  = Math.hypot(dx,dy);

    // weighted by z (closer gates count more)
    const w = d * (0.55 + g.z*0.75);
    if(w < bestD){
      bestD = w;
      best = g;
    }
  }

  if(!best) return { g:null, dist:999, nx:cx, ny:cy };

  const dx = best.x - cx;
  const dy = best.y - cy;
  const d  = Math.hypot(dx,dy);

  return { g:best, dist:d, nx:cx, ny:cy };
}

/*
3) MODIFY your step(dt) function:
   - After you compute state.pitch/state.roll (but before gate collision checks),
     insert this “lock-on” block.
*/
{
  const info = nearestGateInfo();
  const g = info.g;

  let targetLock = 0;
  if(g){
    // tolerance bubble (monk = more generous)
    const tol = state.monk ? (g.r * 1.15) : (g.r * 0.95);
    // lock if you’re meaningfully near center of the gate
    targetLock = clamp(1 - (info.dist / tol), 0, 1);
    // only when the gate is actually “in front of you”
    targetLock *= clamp((0.85 - g.z) / 0.45, 0, 1);
  }

  lockStrength = easeTo(lockStrength, targetLock, 10.0, dt);

  // UI class toggles
  if(lockStrength > 0.22){
    body.classList.add('lock-on');
    body.classList.add('hud-breathe');
  } else {
    body.classList.remove('lock-on');
    body.classList.remove('hud-breathe');
  }

  // “whisper snap”: gentle assistance that never feels like autopilot
  // It nudges your effective aim toward the gate by slightly reducing error.
  if(g && lockStrength > 0.15){
    // nudge in normalized space: shrink the gate-relative error
    const cx = 0.50 + state.roll*0.030;
    const cy = 0.54 + state.pitch*0.024;

    const dx = g.x - cx;
    const dy = g.y - cy;

    // convert to tiny control adjustments
    // roll controls x, pitch controls y (inverted feels more natural)
    const assist = (state.monk ? 0.55 : 0.42) * lockStrength;

    // apply micro-assist directly to state.roll/state.pitch (very small)
    state.roll  = clamp(state.roll  + (dx * 0.55) * assist, -1, 1);
    state.pitch = clamp(state.pitch + (dy * 0.45) * assist, -1, 1);
  }
}

/*
4) OPTIONAL: Make the mission line “whisper” when lock engages.
   Add this inside the same block above, after lockStrength updates:
*/
if(lockStrength > 0.55 && state._lockWhispered !== true){
  state._lockWhispered = true;
  flashMission("Lock: gentle. Center holds.");
  pulse(ui.missionBox);
}
if(lockStrength < 0.25){
  state._lockWhispered = false;
}
</script>
