<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EMBERWING // CIRRUS x HAVEN</title>
  <style>
    :root{
      --ink:#d7e3ff; --muted:rgba(215,227,255,.72); --dim:rgba(215,227,255,.45);
      --line:rgba(215,227,255,.16);
      --glass:rgba(10,16,30,.38);
      --shadow:rgba(0,0,0,.45);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{ height:100%; margin:0; overflow:hidden; background:#05070b; color:var(--ink); }
    #wrap{ position:fixed; inset:0; }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    #hud{ position:absolute; inset:0; pointer-events:none; user-select:none; font-family:var(--sans); letter-spacing:.2px; }
    .topbar{ position:absolute; left:20px; right:20px; top:16px; display:flex; justify-content:space-between; gap:14px; }
    .brand,.panel,.help,.status{
      padding:12px 14px; border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(10,16,30,.40), rgba(10,16,30,.16));
      border:1px solid var(--line);
      box-shadow: 0 18px 50px var(--shadow);
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    }
    .brand{ max-width:min(560px, 52vw); display:flex; flex-direction:column; gap:6px; }
    .title{ font-family:var(--mono); font-size:12px; text-transform:uppercase; display:flex; align-items:center; gap:10px; color:rgba(215,227,255,.9); }
    .dot{ width:8px;height:8px;border-radius:99px; background: radial-gradient(circle at 30% 30%, rgba(255,210,160,1), rgba(255,190,120,.2)); box-shadow: 0 0 16px rgba(255,190,120,.55); }
    .subtitle{ font-size:12.5px; color:var(--muted); line-height:1.25; }
    .subtitle b{ color:rgba(215,227,255,.92); font-weight:600; }
    .rightstack{ display:flex; gap:12px; align-items:flex-start; }
    .panel{ min-width: 220px; }
    .hdr{ font-family:var(--mono); font-size:11px; text-transform:uppercase; color:rgba(215,227,255,.8); display:flex; justify-content:space-between; margin-bottom:10px; }
    .badge{ font-family:var(--mono); font-size:10px; padding:3px 8px; border-radius:999px; border:1px solid var(--line); color:rgba(215,227,255,.82); background: rgba(10,16,30,.14); }
    .kv{ display:grid; grid-template-columns: 1fr auto; gap:8px 14px; align-items:center; font-size:12.5px; }
    .k{ color:var(--dim); font-family:var(--mono); font-size:11px; text-transform:uppercase; letter-spacing:.5px; }
    .v{ color:rgba(215,227,255,.92); font-family:var(--mono); font-size:12px; font-variant-numeric: tabular-nums; }

    .bottom{ position:absolute; left:20px; right:20px; bottom:18px; display:flex; justify-content:space-between; gap:12px; align-items:flex-end; }
    .help{ max-width:min(680px, 62vw); display:flex; flex-direction:column; gap:8px; }
    .help .row{ display:flex; flex-wrap:wrap; gap:10px 14px; align-items:center; color:var(--muted); font-size:12.5px; }
    .key{ font-family:var(--mono); font-size:11px; padding:3px 8px; border-radius:9px; border:1px solid rgba(215,227,255,.2); color:rgba(215,227,255,.86); background: rgba(10,16,30,.18); }

    .status{ min-width: 300px; }
    .big{ font-family:var(--mono); font-size:12px; text-transform:uppercase; letter-spacing:.6px; display:flex; justify-content:space-between; gap:10px; margin-bottom:8px; color:rgba(215,227,255,.92); }
    .bar{ height:8px; border-radius:999px; background: rgba(215,227,255,.10); border:1px solid rgba(215,227,255,.14); overflow:hidden; position:relative; }
    .fill{ position:absolute; inset:0; width:50%; background: linear-gradient(90deg, rgba(120,210,255,.15), rgba(120,210,255,.75)); box-shadow: 0 0 18px rgba(120,210,255,.35); }

    #grain{ position:absolute; inset:0; pointer-events:none; opacity:.06; mix-blend-mode: overlay;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
      background-size:240px 240px;
    }
    #vignette{ position:absolute; inset:-2px; pointer-events:none;
      background: radial-gradient(1200px 760px at 50% 40%, rgba(0,0,0,0) 0%, rgba(0,0,0,.28) 58%, rgba(0,0,0,.58) 100%);
    }

    .monk #hud .brand, .monk #hud .panel, .monk #hud .help, .monk #hud .status{
      opacity:.16; filter:saturate(.65);
    }
    .monk #hud .help{ display:none; }

    @media (max-width: 980px){
      .panel{ display:none; }
      .status{ min-width: 240px; }
      .brand{ max-width: 72vw; }
    }
  </style>
</head>
<body class="monk">
<div id="wrap">
  <canvas id="c"></canvas>

  <div id="hud" aria-hidden="true">
    <div class="topbar">
      <div class="brand">
        <div class="title"><span class="dot"></span> EMBERWING // CIRRUS x HAVEN <span class="badge" id="modeBadge">MONK</span></div>
        <div class="subtitle">
          Mission: <b>fast forward flight. steady hands.</b> <span id="missionLine">ゆっくりと。今ここ。</span>
        </div>
      </div>
      <div class="rightstack">
        <div class="panel">
          <div class="hdr"><span>NAV</span><span class="badge" id="navBadge">MONK</span></div>
          <div class="kv">
            <div class="k">HDG</div><div class="v" id="hdg">000</div>
            <div class="k">ALT</div><div class="v" id="alt">00000</div>
            <div class="k">SPD</div><div class="v" id="spd">000</div>
            <div class="k">BOOST</div><div class="v" id="bst">OFF</div>
          </div>
        </div>
        <div class="panel">
          <div class="hdr"><span>MISSION</span><span class="badge" id="msBadge">FLOW</span></div>
          <div class="kv">
            <div class="k">GATES</div><div class="v" id="gates">0</div>
            <div class="k">MISS</div><div class="v" id="miss">0</div>
            <div class="k">SCORE</div><div class="v" id="score">0000</div>
            <div class="k">RANGE</div><div class="v" id="range">—</div>
          </div>
        </div>
      </div>
    </div>

    <div class="bottom">
      <div class="help">
        <div class="row">
          <span class="key">↑/↓</span> pitch
          <span class="key">←/→</span> roll
          <span class="key">SPACE</span> boost
          <span class="key">CAPS</span> monk
          <span class="key">ENTER</span> HUD
        </div>
      </div>
      <div class="status">
        <div class="big"><span>WATTAGE</span><span class="badge" id="wattBadge">STEADY</span></div>
        <div class="bar"><div class="fill" id="wattFill"></div></div>
        <div class="kv" style="margin-top:10px">
          <div class="k">SIGNAL</div><div class="v" id="signal">CLEAN</div>
          <div class="k">LOCK</div><div class="v" id="lock">FORWARD</div>
        </div>
      </div>
    </div>
  </div>

  <div id="grain"></div>
  <div id="vignette"></div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:true });

  const scene = document.createElement("canvas");
  const sctx = scene.getContext("2d", { alpha:true });
  const bloom1 = document.createElement("canvas");
  const b1 = bloom1.getContext("2d", { alpha:true });
  const bloom2 = document.createElement("canvas");
  const b2 = bloom2.getContext("2d", { alpha:true });

  const $ = (id)=>document.getElementById(id);
  const ui = {
    modeBadge:$("modeBadge"), missionLine:$("missionLine"),
    hdg:$("hdg"), alt:$("alt"), spd:$("spd"), bst:$("bst"),
    gates:$("gates"), miss:$("miss"), score:$("score"), range:$("range"),
    msBadge:$("msBadge"), navBadge:$("navBadge"),
    wattFill:$("wattFill"), wattBadge:$("wattBadge"), signal:$("signal"), lock:$("lock"),
    hud: $("hud")
  };

  const TAU = Math.PI*2;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const fmt3=(n)=>String(Math.round(((n%360)+360)%360)).padStart(3,"0");
  const fmtAlt=(n)=>String(Math.round(n)).padStart(5,"0");
  const fmtSpd=(n)=>String(Math.round(n)).padStart(3,"0");

  const S = {
    t:0, dt:0,
    monk:true, hudVisible:true,
    keys:new Set(),

    // flight feel: subtle hands, strong forward
    pitch:0, roll:0,
    pitchV:0, rollV:0,
    heading:0,
    altitude:38100,

    throttle:0.62,
    boost:false,
    speed:520,
    targetSpeed:520,

    driftX:0, driftY:0,

    gatesHit:0, gatesMiss:0, score:0,
    wattage:0.86, signalClean:1.0,

    audioOn:false,
    audio:null
  };

  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth*dpr);
    canvas.height = Math.floor(innerHeight*dpr);
    canvas.style.width = innerWidth+"px";
    canvas.style.height = innerHeight+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);

    scene.width = Math.floor(innerWidth*dpr);
    scene.height = Math.floor(innerHeight*dpr);
    sctx.setTransform(dpr,0,0,dpr,0,0);

    const bw = Math.floor(innerWidth/2);
    const bh = Math.floor(innerHeight/2);
    bloom1.width = bw; bloom1.height = bh;
    bloom2.width = bw; bloom2.height = bh;
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // --- Audio (same as the strong build) ---
  function initAudio(){
    if (S.audioOn) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    const ac = new AC();

    const master = ac.createGain();
    master.gain.value = 0.0;
    master.connect(ac.destination);

    const osc1 = ac.createOscillator(); osc1.type="sawtooth";
    const osc2 = ac.createOscillator(); osc2.type="sine";
    const engGain = ac.createGain(); engGain.gain.value = 0.0;

    const filter = ac.createBiquadFilter(); filter.type="lowpass"; filter.frequency.value=520;

    const noiseBuf = ac.createBuffer(1, ac.sampleRate*2, ac.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1)*0.25;
    const noise = ac.createBufferSource(); noise.buffer=noiseBuf; noise.loop=true;
    const noiseGain = ac.createGain(); noiseGain.gain.value=0.0;
    const noiseHP = ac.createBiquadFilter(); noiseHP.type="highpass"; noiseHP.frequency.value=120;

    const beep = ac.createOscillator(); beep.type="sine"; beep.frequency.value=880;
    const beepGain = ac.createGain(); beepGain.gain.value=0.0;

    osc1.connect(engGain); osc2.connect(engGain);
    engGain.connect(filter); filter.connect(master);

    noise.connect(noiseHP); noiseHP.connect(noiseGain); noiseGain.connect(master);

    beep.connect(beepGain); beepGain.connect(master);

    osc1.start(); osc2.start(); noise.start(); beep.start();

    master.gain.setValueAtTime(0.0, ac.currentTime);
    master.gain.linearRampToValueAtTime(0.55, ac.currentTime + 0.35);

    S.audioOn = true;
    S.audio = { ac, master, osc1, osc2, engGain, filter, noiseGain, beepGain };
  }

  function updateAudio(){
    if (!S.audioOn) return;
    const { ac, osc1, osc2, engGain, filter, noiseGain, beepGain } = S.audio;
    const heat = clamp(S.throttle + (S.boost?0.45:0), 0, 1);
    const rpm = 190 + heat*640 + (Math.abs(S.roll)+Math.abs(S.pitch))*45;
    const rumble = 0.10 + heat*0.34;

    engGain.gain.setTargetAtTime( rumble * (S.monk?0.82:1.0), ac.currentTime, 0.04 );
    osc1.frequency.setTargetAtTime( rpm, ac.currentTime, 0.05 );
    osc2.frequency.setTargetAtTime( rpm*0.5, ac.currentTime, 0.06 );
    filter.frequency.setTargetAtTime( 420 + heat*1300, ac.currentTime, 0.05 );
    noiseGain.gain.setTargetAtTime( (0.02 + heat*0.10) * (S.monk?0.70:1.0), ac.currentTime, 0.08 );

    const warn = (S.wattage < 0.18) ? (0.12 + 0.08*Math.sin(S.t*6)) : 0.0;
    beepGain.gain.setTargetAtTime( warn, ac.currentTime, 0.04 );
  }

  function onKey(e, down){
    const k = e.code;
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space","Enter","CapsLock"].includes(k)) e.preventDefault();
    if (down && !S.audioOn && (k==="Space"||k.startsWith("Arrow")||k==="CapsLock"||k==="Enter")) initAudio();

    if (down) S.keys.add(k); else S.keys.delete(k);
    if (k==="Space") S.boost = down;

    if (down && k==="CapsLock"){
      S.monk = !S.monk;
      document.body.classList.toggle("monk", S.monk);
      ui.modeBadge.textContent = S.monk ? "MONK" : "LIVE";
      ui.navBadge.textContent = S.monk ? "MONK" : (S.boost ? "BOOST" : "NORM");
      ui.missionLine.textContent = S.monk ? "ゆっくりと。今ここ。" : "Ignition → Glide → Create.";
    }
    if (down && k==="Enter"){
      S.hudVisible = !S.hudVisible;
      ui.hud.style.display = S.hudVisible ? "block" : "none";
    }
  }
  addEventListener("keydown", (e)=>onKey(e,true), {passive:false});
  addEventListener("keyup", (e)=>onKey(e,false), {passive:false});

  // --- Serene sky (O'Keeffe-ish) but not sleepy ---
  function drawHorizon(g,w,h){
    const cx=w*0.5;
    const horizonY=h*0.52 + (S.pitch*95);

    const sky=g.createLinearGradient(0,0,0,h);
    sky.addColorStop(0,"#05070b");
    sky.addColorStop(0.16,"#081427");
    sky.addColorStop(0.42,"#13345f");
    sky.addColorStop(0.68,"#3c7db0");  // clear, serene blue
    sky.addColorStop(1,"#0a2343");
    g.fillStyle=sky; g.fillRect(0,0,w,h);

    // soft “paint glow”
    const glow=g.createRadialGradient(w*0.52,h*0.32,0,w*0.52,h*0.32,Math.max(w,h)*0.85);
    glow.addColorStop(0,"rgba(255,245,235,0.08)");
    glow.addColorStop(0.45,"rgba(185,235,255,0.06)");
    glow.addColorStop(1,"rgba(0,0,0,0)");
    g.fillStyle=glow; g.fillRect(0,0,w,h);

    g.save();
    g.translate(cx,horizonY);
    g.rotate(-S.roll*0.55);

    const band=g.createLinearGradient(0,-60,0,90);
    band.addColorStop(0,"rgba(255,255,255,0)");
    band.addColorStop(0.48,"rgba(190,235,255,0.10)");
    band.addColorStop(0.58,"rgba(255,210,170,0.06)");
    band.addColorStop(1,"rgba(0,0,0,0)");
    g.fillStyle=band; g.fillRect(-w,-80,w*2,160);

    g.globalAlpha=0.22;
    g.strokeStyle="rgba(215,227,255,0.55)";
    g.lineWidth=1;
    g.beginPath(); g.moveTo(-w,0); g.lineTo(w,0); g.stroke();
    g.globalAlpha=1;
    g.restore();
  }

  // --- Airflow streaks (speed cue) ---
  const flow=[];
  const FLOW_COUNT=520;
  function initFlow(){
    flow.length=0;
    for (let i=0;i<FLOW_COUNT;i++){
      flow.push({ x:Math.random()*2-1, y:Math.random()*2-1, z:Math.random(), s:Math.random()*1.2+0.2 });
    }
  }
  initFlow();

  function drawFlow(g,w,h,dt,forward){
    const cx=w*0.5, cy=h*0.42;
    const speed = (0.85 + forward*1.85); // <- THIS is why it feels like flying
    for (const f of flow){
      f.z -= dt*(0.85 + (1-f.z)*3.2)*speed;
      if (f.z<=0.02){ f.x=Math.random()*2-1; f.y=Math.random()*2-1; f.z=1; f.s=Math.random()*1.2+0.2; }
      const p = 0.14/(f.z+0.06);
      const x = cx + (f.x + S.driftX*0.0011)*w*p;
      const y = cy + (f.y + S.driftY*0.0011)*h*p;

      const len = (10 + (1-f.z)*52) * speed;
      const a = (0.05 + (1-f.z)*0.25) * (S.monk?0.82:1);
      g.globalAlpha = a;
      g.strokeStyle = "rgba(205,235,255,0.75)";
      g.lineWidth = Math.max(1, f.s*(1-f.z)*1.5);
      g.beginPath();
      g.moveTo(x,y);
      g.lineTo(x, y + len*p);
      g.stroke();
    }
    g.globalAlpha=1; g.lineWidth=1;
  }

  // --- Gates (kept from strong build) ---
  const gates=[];
  let gateTimer=0;
  function spawnGate(){
    const spread = S.monk ? 0.55 : 0.75;
    gates.push({
      x:(Math.random()*2-1)*spread,
      y:(Math.random()*2-1)*spread*0.55,
      z: 2200 + Math.random()*1400,
      r: 0.24 + Math.random()*0.12,
      hit:false
    });
  }

  function updateGates(dt, forward){
    for (let i=gates.length-1;i>=0;i--){
      const g=gates[i];
      g.z -= dt * (forward*820 + 220);
      if (g.z < 120){
        if (!g.hit){
          S.gatesMiss++;
          S.wattage = clamp(S.wattage - 0.06, 0, 1);
          S.signalClean = clamp(S.signalClean - 0.08, 0, 1);
        }
        gates.splice(i,1);
      }
    }
    gateTimer += dt * (S.monk ? 0.90 : 1.0);
    if (gateTimer > 1.0){
      gateTimer = 0;
      if (gates.length < 4) spawnGate();
    }

    const shipAimX = clamp(S.roll * 0.52, -1, 1);
    const shipAimY = clamp(-S.pitch * 0.72, -1, 1);
    for (const g of gates){
      if (g.hit) continue;
      if (g.z < 520 && g.z > 200){
        const dx = (shipAimX - g.x);
        const dy = (shipAimY - g.y);
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < (g.r*0.78)){
          g.hit = true;
          S.gatesHit++;
          S.score += 28 + Math.round(70 * S.signalClean);
          S.wattage = clamp(S.wattage + 0.03, 0, 1);
          S.signalClean = clamp(S.signalClean + 0.05, 0, 1);
        }
      }
    }
  }

  function drawGates(g, w, h){
    const cx=w*0.5, cy=h*0.44;
    for (const gt of gates){
      const z = gt.z;
      const p = 900 / (z + 220);
      const x = cx + (gt.x + S.driftX*0.0006) * w * 0.55 * p;
      const y = cy + (gt.y + S.driftY*0.0006) * h * 0.45 * p;
      const r = Math.max(18, gt.r * Math.min(w,h) * 0.45 * p);

      const a = clamp(0.08 + (1200 - z)/1200 * 0.35, 0.08, 0.40) * (S.monk ? 0.78 : 1);
      g.globalAlpha = a;

      g.save();
      g.translate(x,y);
      g.globalCompositeOperation="lighter";

      const glow = g.createRadialGradient(0,0,r*0.65, 0,0,r*1.25);
      glow.addColorStop(0, "rgba(120,210,255,0.0)");
      glow.addColorStop(0.55,"rgba(120,210,255,0.24)");
      glow.addColorStop(1, "rgba(255,190,120,0.0)");

      g.strokeStyle = gt.hit ? "rgba(120,255,190,0.70)" : "rgba(190,220,255,0.70)";
      g.lineWidth = Math.max(1, r*0.06);
      g.beginPath(); g.arc(0,0,r,0,TAU); g.stroke();

      g.fillStyle = glow;
      g.beginPath(); g.arc(0,0,r*1.12,0,TAU); g.fill();

      g.globalCompositeOperation="source-over";
      g.restore();
      g.globalAlpha = 1;
    }
  }

  // --- Engine particles (kept) ---
  const particles=[];
  function spawnParticle(){
    const heat = clamp(S.throttle + (S.boost?0.55:0), 0, 1);
    const rate = 14 + heat*46;
    const n = Math.floor(rate*S.dt);
    for (let i=0;i<n;i++){
      particles.push({
        x:0,y:0,
        vx:(Math.random()*2-1)*(16+heat*18),
        vy:(40+Math.random()*55) + heat*120,
        life:0.35+Math.random()*0.35,
        a:0.30+Math.random()*0.22,
        s:1.0+Math.random()*2.4,
      });
    }
  }

  function updateParticles(dt){
    for (let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.life -= dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= (1 - dt*1.8);
      p.vy *= (1 - dt*0.8);
      if (p.life<=0) particles.splice(i,1);
    }
  }

  function drawParticles(g, shipX, shipY){
    const heat = clamp(S.throttle + (S.boost?0.55:0), 0, 1);
    const bloom = 0.18 + heat*0.90;
    g.save();
    g.translate(shipX, shipY);
    g.globalCompositeOperation = "lighter";
    for (const p of particles){
      const a = p.a * (p.life/0.7) * (S.monk?0.75:1);
      g.globalAlpha = a;
      const rad = 10 + p.s*6;
      const grd = g.createRadialGradient(p.x, 104+p.y, 1, p.x, 104+p.y, rad);
      grd.addColorStop(0, `rgba(255,240,220,${0.35*bloom})`);
      grd.addColorStop(0.35, `rgba(255,190,120,${0.22*bloom})`);
      grd.addColorStop(1, "rgba(255,190,120,0)");
      g.fillStyle = grd;
      g.beginPath();
      g.arc(p.x, 104+p.y, rad, 0, TAU);
      g.fill();
    }
    g.restore();
    g.globalAlpha=1;
    g.globalCompositeOperation="source-over";
  }

  // --- NEW: technical SR22-ish aircraft (shaded, weighty, not a logo) ---
  function drawSR22(g,w,h){
    const cx=w*0.5, cy=h*0.66;

    // subtle “pilot” drift (small)
    const sx = cx + S.driftX*0.10;
    const sy = cy + S.driftY*0.08;

    // slight bank visible, but disciplined
    const bank = S.roll * 0.42;

    g.save();
    g.translate(sx,sy);
    g.rotate(bank);

    // ground shadow
    g.globalAlpha=0.26;
    g.fillStyle="rgba(0,0,0,0.55)";
    g.beginPath(); g.ellipse(0,70,260,30,0,0,TAU); g.fill();
    g.globalAlpha=1;

    // materials
    const wing = g.createLinearGradient(-320,10,320,70);
    wing.addColorStop(0, "rgba(245,249,252,0.96)");
    wing.addColorStop(0.55,"rgba(210,228,242,0.94)");
    wing.addColorStop(1, "rgba(160,190,214,0.90)");

    const fuse = g.createLinearGradient(-30,-140, 40,160);
    fuse.addColorStop(0, "rgba(250,252,255,0.98)");
    fuse.addColorStop(0.40,"rgba(225,238,248,0.96)");
    fuse.addColorStop(1, "rgba(170,200,222,0.92)");

    const darkLine = "rgba(40,70,110,0.22)";
    const specLine = "rgba(255,255,255,0.28)";

    // Wings: tapered with slight leading edge bite
    g.fillStyle = wing;
    g.strokeStyle = darkLine;
    g.lineWidth = 1;

    g.beginPath();
    g.moveTo(-320, 46);
    g.quadraticCurveTo(-210, -12, -70, 18);
    g.quadraticCurveTo(0, 30, 70, 18);
    g.quadraticCurveTo(210, -12, 320, 46);
    g.quadraticCurveTo(210, 108, 62, 82);
    g.quadraticCurveTo(0, 74, -62, 82);
    g.quadraticCurveTo(-210, 108, -320, 46);
    g.closePath();
    g.fill();
    g.stroke();

    // Wing root fairing darker (adds “hardware”)
    g.globalAlpha=0.22;
    g.fillStyle="rgba(10,16,30,0.55)";
    g.beginPath();
    g.ellipse(0,52,150,44,0,0,TAU);
    g.fill();
    g.globalAlpha=1;

    // Fuselage: longer, more SR proportions
    g.fillStyle = fuse;
    g.strokeStyle = darkLine;

    g.beginPath();
    g.moveTo(0,-150);
    g.bezierCurveTo(-26,-150,-42,-120,-42,-86);
    g.lineTo(-32,120);
    g.bezierCurveTo(-28,154,-16,178,0,192);
    g.bezierCurveTo(16,178,28,154,32,120);
    g.lineTo(42,-86);
    g.bezierCurveTo(42,-120,26,-150,0,-150);
    g.closePath();
    g.fill(); g.stroke();

    // Cowling/nose cone
    g.fillStyle="rgba(200,215,228,0.95)";
    g.beginPath();
    g.ellipse(0,-150,22,18,0,0,TAU);
    g.fill();

    // Prop disc (subtle)
    g.globalAlpha=0.10;
    g.fillStyle="rgba(255,255,255,0.9)";
    g.beginPath();
    g.ellipse(0,-162,70,26,0,0,TAU);
    g.fill();
    g.globalAlpha=1;

    // Cabin / windshield (dark glass)
    const glass=g.createRadialGradient(0,-88,4, 0,-78,70);
    glass.addColorStop(0,"rgba(10,16,30,0.62)");
    glass.addColorStop(0.55,"rgba(10,16,30,0.28)");
    glass.addColorStop(1,"rgba(10,16,30,0)");
    g.fillStyle=glass;
    g.beginPath();
    g.ellipse(0,-88,52,44,0,0,TAU);
    g.fill();

    // Tailplane + vertical fin hint
    g.fillStyle="rgba(225,238,248,0.92)";
    g.strokeStyle=darkLine;

    g.beginPath();
    g.moveTo(-96, 120);
    g.quadraticCurveTo(0, 88, 96, 120);
    g.quadraticCurveTo(32, 160, 0, 164);
    g.quadraticCurveTo(-32, 160, -96, 120);
    g.closePath();
    g.fill(); g.stroke();

    g.globalAlpha=0.18;
    g.fillStyle="rgba(10,16,30,0.55)";
    g.beginPath();
    g.ellipse(0,126,58,18,0,0,TAU);
    g.fill();
    g.globalAlpha=1;

    // Centerline + panel lines (tiny)
    g.strokeStyle = specLine;
    g.globalAlpha=0.35;
    g.beginPath(); g.moveTo(0,-146); g.lineTo(0,176); g.stroke();
    g.globalAlpha=0.22;
    g.beginPath();
    g.moveTo(-10,-110); g.lineTo(-10,110);
    g.moveTo(10,-110);  g.lineTo(10,110);
    g.stroke();
    g.globalAlpha=1;

    // return ship position for particles
    g.restore();
    return { sx, sy };
  }

  // --- Controls: subtle hands, strong forward (not sleepy) ---
  function updateFlight(dt){
    const up = S.keys.has("ArrowUp");
    const dn = S.keys.has("ArrowDown");
    const lf = S.keys.has("ArrowLeft");
    const rt = S.keys.has("ArrowRight");

    const calm = S.monk ? 0.82 : 1.0; // monk reduces twitch, NOT speed

    const pIn = (up?1:0) + (dn?-1:0);
    const rIn = (rt?1:0) + (lf?-1:0);

    // subtle pilot inputs: small max deflection, quick settle
    const pitchTarget = pIn * 0.26 * calm;
    const rollTarget  = rIn * 0.40 * calm;

    S.pitch = lerp(S.pitch, pitchTarget, dt*7.2);
    S.roll  = lerp(S.roll,  rollTarget,  dt*7.2);

    // strong forward baseline
    const base=520, max=820, boostAdd=S.boost?240:0;
    S.targetSpeed = base + (max-base)*S.throttle + boostAdd;

    const resp = S.boost ? 2.6 : 1.6;
    S.speed += (S.targetSpeed - S.speed) * dt * resp;

    // quiet altitude change
    S.altitude += (S.pitch * 3200 + (S.boost?220:0)) * dt;

    // bank-to-turn
    const turn = S.roll * (0.70 + (S.speed/900)) * calm;
    S.heading += (turn * 54) * dt;

    // drift (small)
    S.driftX = lerp(S.driftX, S.roll * 180, dt * 2.4);
    S.driftY = lerp(S.driftY, -S.pitch * 220, dt * 2.4);

    // meters
    const stress = (S.boost ? 0.40 : 0) + (Math.abs(S.roll)+Math.abs(S.pitch))*0.55;
    const recover = (S.monk ? 0.22 : 0.12);
    S.wattage = clamp(S.wattage + (recover - stress) * dt * 0.34, 0, 1);

    const steady = 1 - clamp(stress,0,1);
    S.signalClean = clamp(lerp(S.signalClean, steady, dt * 0.60), 0, 1);
  }

  // --- Post (bloom) ---
  function blurPass(srcCtx, dstCtx, w, h, passes){
    dstCtx.clearRect(0,0,w,h);
    dstCtx.globalAlpha = 1 / (passes*2 + 1);
    for (let i=-passes;i<=passes;i++){
      dstCtx.drawImage(srcCtx.canvas, i, 0, w, h);
      dstCtx.drawImage(srcCtx.canvas, 0, i, w, h);
    }
    dstCtx.globalAlpha = 1;
  }

  function updateUI(forward){
    ui.hdg.textContent = fmt3(S.heading);
    ui.alt.textContent = fmtAlt(S.altitude);
    ui.spd.textContent = fmtSpd(S.speed);
    ui.bst.textContent = S.boost ? "ON" : "OFF";
    ui.navBadge.textContent = S.boost ? "BOOST" : (S.monk ? "MONK" : "NORM");

    ui.gates.textContent = String(S.gatesHit);
    ui.miss.textContent  = String(S.gatesMiss);
    ui.score.textContent = String(S.score).padStart(4,"0");

    let nearest=null;
    for (const g of gates){ if (!g.hit && (nearest===null || g.z<nearest)) nearest=g.z; }
    ui.range.textContent = nearest ? Math.round(nearest)+"m" : "—";

    ui.wattFill.style.width = Math.round(S.wattage*100) + "%";
    ui.wattBadge.textContent = S.wattage > 0.75 ? "STEADY" : (S.wattage > 0.4 ? "WORKING" : "LOW");
    ui.signal.textContent = S.signalClean > 0.78 ? "CLEAN" : (S.signalClean > 0.45 ? "NOISY" : "FRAY");
    ui.lock.textContent = "FORWARD";
    ui.msBadge.textContent = "FLOW";
  }

  function render(){
    const w=innerWidth, h=innerHeight;

    // motion persistence for trails (but not smear)
    sctx.globalAlpha = 0.14 + (S.monk ? 0.04 : 0);
    sctx.fillStyle = "rgba(5,7,11,0.88)";
    sctx.fillRect(0,0,w,h);
    sctx.globalAlpha = 1;

    drawHorizon(sctx,w,h);

    const forward = clamp((S.speed/620) + (S.boost?0.62:0), 0.55, 2.20);

    drawFlow(sctx,w,h,S.dt,forward);
    drawGates(sctx,w,h);

    spawnParticle();
    updateParticles(S.dt);

    const ship = drawSR22(sctx,w,h);
    drawParticles(sctx, ship.sx, ship.sy);

    // mild tunnel pulse
    sctx.globalAlpha = (0.05 + forward*0.05) * (S.monk?0.78:1);
    const cx=w*0.5, cy=h*0.44;
    const ring = sctx.createRadialGradient(cx,cy,Math.min(w,h)*0.08, cx,cy,Math.min(w,h)*0.62);
    ring.addColorStop(0,"rgba(120,210,255,0.0)");
    ring.addColorStop(0.35,"rgba(120,210,255,0.08)");
    ring.addColorStop(0.60,"rgba(255,190,120,0.05)");
    ring.addColorStop(1,"rgba(0,0,0,0)");
    sctx.fillStyle=ring;
    sctx.fillRect(0,0,w,h);
    sctx.globalAlpha = 1;

    // bloom downsample + blur
    b1.clearRect(0,0,bloom1.width,bloom1.height);
    b1.globalAlpha = 0.78;
    b1.drawImage(scene, 0, 0, bloom1.width, bloom1.height);
    b1.globalAlpha = 1;

    b2.clearRect(0,0,bloom2.width,bloom2.height);
    blurPass(b1, b2, bloom2.width, bloom2.height, 4);

    ctx.clearRect(0,0,w,h);
    ctx.drawImage(scene, 0, 0, w, h);

    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = (S.monk ? 0.48 : 0.62);
    ctx.drawImage(bloom2.canvas, 0, 0, w, h);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";

    return forward;
  }

  let last = performance.now();
  function tick(now){
    S.dt = Math.min(0.033, (now-last)/1000);
    last = now;
    S.t += S.dt;

    updateFlight(S.dt);

    const forward = clamp((S.speed/620) + (S.boost?0.62:0), 0.55, 2.20);
    updateGates(S.dt, forward);

    render();
    updateUI(forward);
    updateAudio();

    requestAnimationFrame(tick);
  }

  // seed a couple
  spawnGate(); spawnGate();

  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
