<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emberwing</title>
  <style>
    html,body{height:100%; margin:0; background:#000; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    canvas{position:fixed; inset:0; width:100vw; height:100vh; display:block;}
    .dbg{
      position:fixed; left:14px; bottom:14px;
      font:12px ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      color:rgba(245,246,255,.55);
      letter-spacing:.08em;
      user-select:none;
      pointer-events:none;
      mix-blend-mode:screen;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="dbg" id="dbg">boot</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const dbg = document.getElementById('dbg');

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize);
  resize();

  // INPUT (no per-frame CapsLock flipping)
  const keys = new Set();
  let assistHigh = true;

  addEventListener('keydown', (e) => {
    keys.add(e.key);
    if (e.key === 'CapsLock') assistHigh = !assistHigh;
    if (e.key === ' ') e.preventDefault();
    if (e.key === 'Enter') throttle = Math.max(throttle, 0.82);
    if (e.key === ' ') steady();
  }, { passive:false });

  addEventListener('keyup', (e) => keys.delete(e.key));

  // FLIGHT
  let pitch=0, roll=0, yaw=0;
  let targetPitch=0, targetRoll=0;
  let throttle=0.65;
  let speed=260;
  let altitude=38000;
  let vspeed=0;

  const maxPitch=0.28, maxRoll=0.62;

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function steady(){
    targetPitch *= 0.28;
    targetRoll  *= 0.28;
    vspeed      *= 0.48;
  }

  // CLOUD FIELD
  const clouds = [];
  const COUNT = 240;
  const WORLD = 6400;

  for (let i=0;i<COUNT;i++){
    clouds.push({
      x:(Math.random()*2-1)*WORLD,
      y:(Math.random()*2-1)*WORLD,
      r:50+Math.random()*290,
      a:0.035+Math.random()*0.11,
      l:Math.random()<0.5 ? 0.55 : 0.88
    });
  }

  function wrap(v, m){
    if (v >  m) v -= 2*m;
    if (v < -m) v += 2*m;
    return v;
  }

  // RENDER
  function drawSky(w,h){
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'#05060a');
    g.addColorStop(0.28,'#081228');
    g.addColorStop(0.62,'#0b2a55');
    g.addColorStop(1,'#0f4a86');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const cap = ctx.createRadialGradient(w*0.5,h*0.15, 0, w*0.5,h*0.15, Math.max(w,h)*0.9);
    cap.addColorStop(0,'rgba(255,255,255,0.05)');
    cap.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = cap;
    ctx.fillRect(0,0,w,h);
  }

  function drawHorizon(w,h){
    const cx=w/2, cy=h/2;
    const lift = pitch*(h*0.95);

    ctx.save();
    ctx.translate(cx, cy + lift);
    ctx.rotate(-roll);

    ctx.strokeStyle = 'rgba(245,246,255,0.09)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-w,0);
    ctx.lineTo(w,0);
    ctx.stroke();

    const haze = ctx.createLinearGradient(0,-160,0,200);
    haze.addColorStop(0,'rgba(255,255,255,0.00)');
    haze.addColorStop(0.55,'rgba(255,255,255,0.03)');
    haze.addColorStop(1,'rgba(255,255,255,0.00)');
    ctx.fillStyle = haze;
    ctx.fillRect(-w,-200,w*2,400);

    ctx.restore();
  }

  function drawClouds(w,h){
    const cx=w/2, cy=h/2;

    const forward = speed * 1.55;        // forward motion lever
    const strafe  = roll  * speed * 0.62;
    const climb   = pitch * speed * 0.55;

    for (const c of clouds){
      // wrap around a moving reference based on yaw so the world feels alive
      const wx = wrap(c.x - yaw*520*c.l, WORLD);
      const wy = wrap(c.y, WORLD);

      const x0 = cx + wx + strafe*c.l;
      const y0 = cy + wy + (forward*0.22*c.l) + (climb*c.l) + h*0.20;

      for (let ox=-1; ox<=1; ox++){
        for (let oy=-1; oy<=1; oy++){
          const x = x0 + ox*(WORLD*2);
          const y = y0 + oy*(WORLD*2);
          if (x < -800 || x > w+800 || y < -800 || y > h+1400) continue;

          const rg = ctx.createRadialGradient(x,y,0, x,y,c.r);
          rg.addColorStop(0, `rgba(255,255,255,${c.a})`);
          rg.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = rg;
          ctx.beginPath();
          ctx.arc(x,y,c.r,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }

  function drawContrails(w,h,now){
    const cx=w/2, cy=h*0.78;
    const len = 520 + speed*2.2;
    const sway = roll*220;

    ctx.save();
    ctx.globalAlpha = 0.10 + clamp((speed-240)/320, 0, 0.14);
    ctx.strokeStyle = 'rgba(245,246,255,0.72)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6,10]);
    ctx.lineDashOffset = now * -0.03;

    ctx.beginPath();
    ctx.moveTo(cx-26, cy+30);
    ctx.bezierCurveTo(cx-70 - sway*0.20, cy+150,
                      cx-160- sway*0.45, cy+290,
                      cx-240- sway*0.70, cy+len);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(cx+26, cy+30);
    ctx.bezierCurveTo(cx+70 - sway*0.20, cy+150,
                      cx+160- sway*0.45, cy+290,
                      cx+240- sway*0.70, cy+len);
    ctx.stroke();

    ctx.restore();
  }

  // VINTAGE CRAFT — guaranteed visible
  function drawCraft(w,h){
    const cx = w/2, cy = h*0.78;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(roll * 0.16);

    const s = Math.min(w,h)/920;
    ctx.scale(s,s);

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.26;
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.beginPath();
    ctx.ellipse(0,132,270,42,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // body (slightly warm)
    ctx.fillStyle = 'rgba(16,16,18,0.75)';
    ctx.beginPath();
    ctx.moveTo(-320,62);
    ctx.quadraticCurveTo(-220,-6,-90,-28);
    ctx.quadraticCurveTo(0,-42,90,-28);
    ctx.quadraticCurveTo(220,-6,320,62);
    ctx.quadraticCurveTo(220,146,90,174);
    ctx.quadraticCurveTo(0,188,-90,174);
    ctx.quadraticCurveTo(-220,146,-320,62);
    ctx.closePath();
    ctx.fill();

    // warm sheen (re-draw same shape with gradient)
    const sheen = ctx.createLinearGradient(0,-40,0,190);
    sheen.addColorStop(0.00,'rgba(255,240,220,0.060)');
    sheen.addColorStop(0.35,'rgba(255,240,220,0.020)');
    sheen.addColorStop(1.00,'rgba(255,240,220,0.000)');
    ctx.fillStyle = sheen;
    ctx.fill();

    // center seam
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0,-26);
    ctx.lineTo(0,176);
    ctx.stroke();

    // tangerine pinstripe
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,140,70,0.60)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-120,118);
    ctx.quadraticCurveTo(0,138,120,118);
    ctx.stroke();
    ctx.restore();

    // ember lamp
    const coreY = 98;

    const glow = ctx.createRadialGradient(0,coreY,0, 0,coreY,86);
    glow.addColorStop(0,'rgba(255,170,95,0.65)');
    glow.addColorStop(0.25,'rgba(255,140,70,0.18)');
    glow.addColorStop(1,'rgba(255,120,60,0.00)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0,coreY,86,0,Math.PI*2);
    ctx.fill();

    const filament = ctx.createRadialGradient(0,coreY,0, 0,coreY,22);
    filament.addColorStop(0,'rgba(255,230,180,0.95)');
    filament.addColorStop(0.55,'rgba(255,150,85,0.35)');
    filament.addColorStop(1,'rgba(255,120,60,0)');
    ctx.fillStyle = filament;
    ctx.beginPath();
    ctx.arc(0,coreY,22,0,Math.PI*2);
    ctx.fill();

    // fail-safe outline so you ALWAYS see the plane
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = 'rgba(245,246,255,0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  // LOOP
  let last = performance.now();
  function step(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    // controls
    const up    = keys.has('ArrowUp');
    const down  = keys.has('ArrowDown');
    const left  = keys.has('ArrowLeft');
    const right = keys.has('ArrowRight');
    const space = keys.has(' ');

    const pitchN = (up?1:0) - (down?1:0);
    const rollN  = (right?1:0) - (left?1:0);

    targetPitch = clamp(targetPitch + pitchN*dt*0.46, -maxPitch, maxPitch);
    targetRoll  = clamp(targetRoll  + rollN *dt*0.84, -maxRoll,  maxRoll);

    if (space) steady();

    // assist (planes fly themselves)
    const relaxPerSec = assistHigh ? 2.1 : 0.75;
    const relax = Math.exp(-relaxPerSec*dt);
    targetPitch *= relax;
    targetRoll  *= relax;

    // ease
    const pitchEase = 1 - Math.pow(assistHigh ? 0.80 : 0.90, dt*60);
    const rollEase  = 1 - Math.pow(assistHigh ? 0.76 : 0.88, dt*60);
    pitch = lerp(pitch, targetPitch, pitchEase);
    roll  = lerp(roll,  targetRoll,  rollEase);

    // heading
    const turnRate = assistHigh ? 0.50 : 0.72;
    yaw += (roll * turnRate) * dt;

    // speed + altitude
    const drag = 0.0016 + Math.abs(roll)*0.0032 + Math.abs(pitch)*0.0042;
    speed += ((throttle*600) - speed) * dt * 0.85;
    speed -= speed * drag * dt * 60;
    speed = clamp(speed, 140, 600);

    vspeed += (pitch * speed * 0.36) * dt * 60;
    vspeed *= Math.pow(assistHigh ? 0.90 : 0.94, dt*60);
    altitude += vspeed * dt * 2.3;
    altitude = clamp(altitude, 5000, 65000);

    // render with guard
    const w = innerWidth, h = innerHeight;
    try{
      drawSky(w,h);
      drawHorizon(w,h);
      drawClouds(w,h);
      drawContrails(w,h,now);
      drawCraft(w,h);
    } catch (err){
      // keep sky visible, and show error
      dbg.textContent = 'ERR: ' + (err && err.message ? err.message : String(err));
      requestAnimationFrame(step);
      return;
    }

    // debug (shows you it’s alive + where we are)
    dbg.textContent =
      `SPD ${Math.round(speed)}  ALT ${Math.round(altitude)}  HDG ${String(Math.round(((yaw*180/Math.PI)%360+360)%360)).padStart(3,'0')}  ASST ${assistHigh?'HI':'LO'}`;

    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
