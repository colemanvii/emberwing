<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Emberwing Gyro Controls</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #05060a; font-family: ui-sans-serif, system-ui; }
    #hud {
      position: fixed; inset: 16px auto auto 16px;
      display: grid; gap: 10px; z-index: 10;
      max-width: calc(100vw - 32px);
    }
    .card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 12px 12px;
      backdrop-filter: blur(10px);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button {
      appearance: none; border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.92);
      padding: 10px 12px; border-radius: 12px;
      font-weight: 600; letter-spacing: 0.2px;
    }
    button:active { transform: translateY(1px); }
    .muted { color: rgba(255,255,255,0.65); font-size: 12px; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; color: rgba(255,255,255,0.85); }
    #statusDot {
      width: 10px; height: 10px; border-radius: 999px;
      background: #ff4d4d; box-shadow: 0 0 16px rgba(255,77,77,0.55);
      display: inline-block; vertical-align: middle; margin-right: 8px;
    }
    #touchPad {
      position: fixed; inset: auto 16px 16px auto;
      width: min(42vw, 220px); height: min(42vw, 220px);
      border-radius: 24px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(8px);
      touch-action: none;
      display: none;
      z-index: 9;
    }
    #touchKnob {
      position: absolute; left: 50%; top: 50%;
      width: 64px; height: 64px; border-radius: 999px;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    canvas { display:block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="hud">
    <div class="card">
      <div class="row">
        <span id="statusDot"></span>
        <span style="color:rgba(255,255,255,0.92);font-weight:700">Emberwing Controls</span>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="btnEnable">Enable Gyro</button>
        <button id="btnCalibrate" title="Sets current device angle as neutral">Calibrate</button>
        <button id="btnTouch">Use Touch</button>
      </div>
      <div class="muted" style="margin-top:10px">
        iPhone requires a tap to allow motion access. Gyro feels best with smoothing + deadzone.
      </div>
      <div class="mono" style="margin-top:10px" id="readout">pitch: 0.000  roll: 0.000  yaw: 0.000</div>
      <div class="mono" style="margin-top:6px" id="mode">mode: waiting</div>
    </div>
  </div>

  <div id="touchPad">
    <div id="touchKnob"></div>
  </div>

  <canvas id="c"></canvas>

  <script>
    // -----------------------------
    // EmberwingGyroControls (drop-in)
    // Outputs: controls.state = { pitch, roll, yaw } in radians-ish normalized range
    // -----------------------------
    class EmberwingGyroControls {
      constructor(opts = {}) {
        this.opts = {
          smoothing: opts.smoothing ?? 0.08, // lower = smoother/laggier; ~0.06–0.12 good
          deadzone: opts.deadzone ?? 0.035,  // ignore tiny tremor
          gainPitch: opts.gainPitch ?? 1.15, // scale response
          gainRoll:  opts.gainRoll  ?? 1.35,
          gainYaw:   opts.gainYaw   ?? 0.55, // yaw is optional; browsers often noisy
          clamp:     opts.clamp     ?? 0.85, // max normalized magnitude
        };

        this.enabled = false;
        this.hasPermission = false;
        this.mode = "waiting"; // waiting | gyro | touch
        this._baseline = { beta: 0, gamma: 0, alpha: 0 };
        this._raw = { beta: 0, gamma: 0, alpha: 0 };
        this._smoothed = { pitch: 0, roll: 0, yaw: 0 };

        this.state = { pitch: 0, roll: 0, yaw: 0 };
        this._onOrientation = this._onOrientation.bind(this);
        this._onMotion = this._onMotion.bind(this);

        // Touch fallback state
        this.touch = {
          active: false,
          x: 0, y: 0, // -1..1
          strength: 0
        };
      }

      // iOS 13+ needs permission prompt
      async requestPermission() {
        const DOE = window.DeviceOrientationEvent;
        if (!DOE) return { ok: false, reason: "DeviceOrientationEvent not supported" };

        // iOS style permission
        if (typeof DOE.requestPermission === "function") {
          const res = await DOE.requestPermission();
          if (res !== "granted") return { ok: false, reason: "Permission denied" };
        }

        this.hasPermission = true;
        return { ok: true };
      }

      startGyro() {
        if (this.enabled) return;
        this.enabled = true;
        this.mode = "gyro";
        window.addEventListener("deviceorientation", this._onOrientation, { passive: true });
        window.addEventListener("devicemotion", this._onMotion, { passive: true }); // optional, for future use
      }

      stopGyro() {
        this.enabled = false;
        window.removeEventListener("deviceorientation", this._onOrientation);
        window.removeEventListener("devicemotion", this._onMotion);
      }

      calibrate() {
        // Use current raw angles as neutral center
        this._baseline.beta = this._raw.beta;
        this._baseline.gamma = this._raw.gamma;
        this._baseline.alpha = this._raw.alpha;
      }

      setTouch(x, y, active) {
        this.mode = "touch";
        this.touch.active = !!active;
        this.touch.x = x;
        this.touch.y = y;
        this.touch.strength = Math.min(1, Math.hypot(x, y));
      }

      update(dt) {
        // Convert device angles to normalized controls
        // deviceorientation: beta (front/back), gamma (left/right), alpha (compass-ish)
        let pitchN = 0, rollN = 0, yawN = 0;

        if (this.mode === "gyro" && this.enabled) {
          const beta = (this._raw.beta - this._baseline.beta);   // degrees
          const gamma = (this._raw.gamma - this._baseline.gamma);// degrees
          const alpha = (this._raw.alpha - this._baseline.alpha);// degrees (not always stable)

          // Map degrees -> normalized ~[-1..1] (tune denominators for "syrupy warp")
          pitchN = beta / 25;   // 25° tilt = full-ish pitch
          rollN  = gamma / 25;  // 25° tilt = full-ish roll
          yawN   = alpha / 90;  // very soft yaw

          // Apply gains
          pitchN *= this.opts.gainPitch;
          rollN  *= this.opts.gainRoll;
          yawN   *= this.opts.gainYaw;

        } else if (this.mode === "touch") {
          // Touch: y up = pitch down (invert for airplane feel)
          pitchN = -this.touch.y * 1.0;
          rollN  =  this.touch.x * 1.0;
          yawN   =  this.touch.x * 0.35; // optional
        }

        // Deadzone
        pitchN = this._applyDeadzone(pitchN, this.opts.deadzone);
        rollN  = this._applyDeadzone(rollN,  this.opts.deadzone);
        yawN   = this._applyDeadzone(yawN,   this.opts.deadzone);

        // Clamp
        pitchN = this._clamp(pitchN, -this.opts.clamp, this.opts.clamp);
        rollN  = this._clamp(rollN,  -this.opts.clamp, this.opts.clamp);
        yawN   = this._clamp(yawN,   -this.opts.clamp, this.opts.clamp);

        // Smooth (EMA)
        const a = 1 - Math.exp(-dt / Math.max(1e-4, this.opts.smoothing));
        this._smoothed.pitch += (pitchN - this._smoothed.pitch) * a;
        this._smoothed.roll  += (rollN  - this._smoothed.roll)  * a;
        this._smoothed.yaw   += (yawN   - this._smoothed.yaw)   * a;

        // Output in a "radians-ish" small range (so it plugs into camera/ship rotations easily)
        this.state.pitch = this._smoothed.pitch * 0.65;
        this.state.roll  = this._smoothed.roll  * 0.85;
        this.state.yaw   = this._smoothed.yaw   * 0.55;
      }

      _onOrientation(e) {
        // Some browsers give nulls until permission is granted
        if (e.beta == null || e.gamma == null) return;
        this._raw.beta = e.beta;
        this._raw.gamma = e.gamma;
        this._raw.alpha = e.alpha ?? 0;
      }

      _onMotion(_e) { /* reserved: could use rotationRate for “true gyro” feel later */ }

      _applyDeadzone(v, dz) {
        const av = Math.abs(v);
        if (av < dz) return 0;
        // Rescale so it ramps smoothly after deadzone
        const s = (av - dz) / (1 - dz);
        return Math.sign(v) * s;
      }

      _clamp(v, lo, hi) { return Math.min(hi, Math.max(lo, v)); }
    }

    // -----------------------------
    // Demo loop (replace with your game loop)
    // -----------------------------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const readout = document.getElementById("readout");
    const modeEl = document.getElementById("mode");
    const dot = document.getElementById("statusDot");

    const btnEnable = document.getElementById("btnEnable");
    const btnCal = document.getElementById("btnCalibrate");
    const btnTouch = document.getElementById("btnTouch");

    const touchPad = document.getElementById("touchPad");
    const touchKnob = document.getElementById("touchKnob");

    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    addEventListener("resize", resize, { passive: true });
    resize();

    const controls = new EmberwingGyroControls({
      smoothing: 0.09,
      deadzone: 0.04,
      gainPitch: 1.2,
      gainRoll: 1.35,
      gainYaw: 0.45,
      clamp: 0.9
    });

    function setStatus(on) {
      dot.style.background = on ? "#3cff7a" : "#ff4d4d";
      dot.style.boxShadow = on ? "0 0 16px rgba(60,255,122,0.55)" : "0 0 16px rgba(255,77,77,0.55)";
    }

    btnEnable.addEventListener("click", async () => {
      try {
        const res = await controls.requestPermission();
        if (!res.ok) {
          controls.mode = "touch";
          modeEl.textContent = `mode: touch (gyro unavailable: ${res.reason})`;
          touchPad.style.display = "block";
          setStatus(false);
          return;
        }
        controls.startGyro();
        controls.calibrate();
        touchPad.style.display = "none";
        setStatus(true);
        modeEl.textContent = "mode: gyro (tilt to fly) — tap Calibrate if drift";
      } catch (err) {
        controls.mode = "touch";
        touchPad.style.display = "block";
        setStatus(false);
        modeEl.textContent = `mode: touch (error: ${String(err)})`;
      }
    });

    btnCal.addEventListener("click", () => {
      controls.calibrate();
      modeEl.textContent = controls.mode === "gyro"
        ? "mode: gyro (re-centered)"
        : "mode: touch";
    });

    btnTouch.addEventListener("click", () => {
      controls.stopGyro();
      controls.mode = "touch";
      touchPad.style.display = "block";
      setStatus(false);
      modeEl.textContent = "mode: touch (drag the pad)";
    });

    // Touchpad handling
    const padState = { pointerId: null, cx: 0, cy: 0, radius: 0 };

    function padMetrics() {
      const r = touchPad.getBoundingClientRect();
      padState.cx = r.left + r.width / 2;
      padState.cy = r.top + r.height / 2;
      padState.radius = Math.min(r.width, r.height) * 0.34;
    }
    addEventListener("resize", padMetrics, { passive: true });
    padMetrics();

    function setKnob(nx, ny) {
      const px = nx * padState.radius;
      const py = ny * padState.radius;
      touchKnob.style.left = `calc(50% + ${px}px)`;
      touchKnob.style.top  = `calc(50% + ${py}px)`;
    }

    touchPad.addEventListener("pointerdown", (e) => {
      touchPad.setPointerCapture(e.pointerId);
      padState.pointerId = e.pointerId;
      controls.setTouch(0, 0, true);
      padMetrics();
    });

    touchPad.addEventListener("pointermove", (e) => {
      if (padState.pointerId !== e.pointerId) return;
      const dx = (e.clientX - padState.cx);
      const dy = (e.clientY - padState.cy);
      const r = padState.radius;
      let nx = dx / r;
      let ny = dy / r;
      const mag = Math.hypot(nx, ny);
      if (mag > 1) { nx /= mag; ny /= mag; }
      controls.setTouch(nx, ny, true);
      setKnob(nx, ny);
    });

    function endTouch(e) {
      if (padState.pointerId !== e.pointerId) return;
      padState.pointerId = null;
      controls.setTouch(0, 0, false);
      setKnob(0, 0);
    }
    touchPad.addEventListener("pointerup", endTouch);
    touchPad.addEventListener("pointercancel", endTouch);

    // Minimal “flight” visualization
    let tPrev = performance.now();
    function loop(tNow) {
      const dt = Math.min(0.05, (tNow - tPrev) / 1000);
      tPrev = tNow;

      controls.update(dt);

      // Use these values inside Emberwing:
      // controls.state.pitch / roll / yaw
      const { pitch, roll, yaw } = controls.state;

      readout.textContent =
        `pitch: ${pitch.toFixed(3)}  roll: ${roll.toFixed(3)}  yaw: ${yaw.toFixed(3)}`;

      // Draw calm “horizon” that banks & pitches
      ctx.clearRect(0, 0, innerWidth, innerHeight);
      ctx.save();
      ctx.translate(innerWidth/2, innerHeight/2);
      ctx.rotate(-roll);

      const horizonY = pitch * 220;
      ctx.globalAlpha = 0.9;

      // Sky
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(-innerWidth, -innerHeight, innerWidth*2, innerHeight*2);

      // Horizon line
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-innerWidth, horizonY);
      ctx.lineTo(innerWidth, horizonY);
      ctx.stroke();

      // Center reticle
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = "rgba(255,255,255,0.75)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, 0, 18, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(-40, 0); ctx.lineTo(-18, 0);
      ctx.moveTo(18, 0);  ctx.lineTo(40, 0);
      ctx.stroke();

      // Subtle yaw indicator
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = "rgba(255,255,255,0.45)";
      ctx.fillRect(-2, -90, 4, 28);
      ctx.translate(yaw * 90, 0);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(-2, -90, 4, 28);

      ctx.restore();

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Default: show touch pad on desktop
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    if (!isMobile) {
      controls.mode = "touch";
      touchPad.style.display = "block";
      modeEl.textContent = "mode: touch (desktop)";
      setStatus(false);
    } else {
      setStatus(false);
      modeEl.textContent = "mode: waiting (tap Enable Gyro)";
    }
  </script>
</body>
</html>