<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emberwing — Cruise (Playable)</title>
  <style>
    :root{
      --ink:#05060a;
      --hud:rgba(245,246,255,.10);
      --hud2:rgba(245,246,255,.18);
      --text:rgba(245,246,255,.62);
      --text2:rgba(245,246,255,.42);
      --ember:rgba(255,140,70,.95);
      --ember2:rgba(255,95,35,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:#000;
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:white;
    }

    /* Fullscreen canvas */
    canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
      background: radial-gradient(1200px 700px at 50% 15%, rgba(255,255,255,.05), transparent 60%),
                  linear-gradient(to bottom, #05060a 0%, #081228 24%, #0b2a55 58%, #0f4a86 100%);
    }

    /* HUD overlay */
    .hud{
      position:fixed;
      inset:0;
      pointer-events:none;
      opacity:0;
      transition: opacity 600ms ease;
    }
    .awake .hud{ opacity:1; }

    .hudLine{
      position:absolute; top:10%; bottom:10%;
      width:1px;
      background: linear-gradient(to bottom, transparent 0%, var(--hud) 18%, var(--hud) 82%, transparent 100%);
      filter: blur(.15px);
    }
    .hudLine.left{ left:28px; }
    .hudLine.right{ right:28px; }

    .hudArc{
      position:absolute;
      left:50%; bottom:26px;
      width:min(520px, 78vw);
      height:84px;
      transform:translateX(-50%);
      border-bottom:1px solid var(--hud);
      border-radius: 0 0 999px 999px / 0 0 120px 120px;
      opacity:.9;
    }
    .tick{
      position:absolute; bottom:24px; left:50%;
      width:1px; height:12px;
      transform:translateX(-50%);
      background: linear-gradient(to top, transparent 0%, var(--hud2) 55%, transparent 100%);
      opacity:.6;
    }

    .readouts{
      position:absolute;
      left:26px;
      bottom:26px;
      display:flex;
      gap:18px;
      font-size:12px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--text2);
      user-select:none;
      white-space:nowrap;
    }
    .readouts b{
      color:var(--text);
      font-weight:600;
      letter-spacing:.08em;
      margin-left:6px;
    }

    .hint{
      position:absolute;
      right:26px;
      bottom:26px;
      font-size:12px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:var(--text2);
      opacity:.55;
      user-select:none;
    }

    /* Ember mark (center-bottom) */
    .ember{
      position:absolute;
      left:50%;
      bottom:40px;
      width:10px; height:10px;
      transform:translateX(-50%);
      border-radius:999px;
      background: radial-gradient(circle, var(--ember) 0%, rgba(255,160,90,.75) 22%, rgba(255,120,60,.35) 45%, transparent 70%);
      box-shadow:
        0 0 18px 3px var(--ember2),
        0 0 44px 10px rgba(255,120,60,.12);
      opacity:.85;
      animation: pulse 6.5s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform:translateX(-50%) scale(.95); opacity:.70 }
      50%{ transform:translateX(-50%) scale(1.10); opacity:.95 }
    }

    /* Subtle grain */
    .grain{
      position:fixed; inset:-20%;
      pointer-events:none;
      background:
        repeating-linear-gradient(0deg, transparent 0 2px, rgba(255,255,255,.02) 2px 3px),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      mix-blend-mode:overlay;
      opacity:.10;
      animation: grain 7s steps(2,end) infinite;
    }
    @keyframes grain{ 0%{transform:translate3d(0,0,0)} 100%{transform:translate3d(-3%,2%,0)} }

    /* Click zones to nudge (mobile + mouse) */
    .zones{
      position:fixed; inset:0;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      pointer-events:auto;
    }
    .zone{ background:transparent; border:0; padding:0; }
    .zone:active{ cursor:grabbing; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud" id="hud">
    <div class="hudLine left"></div>
    <div class="hudLine right"></div>
    <div class="hudArc"></div>
    <div class="tick"></div>

    <div class="readouts">
      SPD <b id="spd">—</b>
      ALT <b id="alt">—</b>
      HDG <b id="hdg">—</b>
      THR <b id="thr">—</b>
    </div>

    <div class="hint">W/S pitch · A/D roll · Q/E yaw · ↑/↓ throttle · tap edges to nudge</div>
    <div class="ember"></div>
  </div>

  <div class="grain"></div>

  <div class="zones" aria-label="controls">
    <button class="zone" id="zL" aria-label="nudge left"></button>
    <button class="zone" id="zC" aria-label="steady"></button>
    <button class="zone" id="zR" aria-label="nudge right"></button>
  </div>

<script>
(() => {
  // ----- DOM -----
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const hud = document.getElementById('hud');
  const spdEl = document.getElementById('spd');
  const altEl = document.getElementById('alt');
  const hdgEl = document.getElementById('hdg');
  const thrEl = document.getElementById('thr');

  const zL = document.getElementById('zL');
  const zC = document.getElementById('zC');
  const zR = document.getElementById('zR');

  // ----- Resize -----
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ----- Presence (HUD wakes) -----
  let awakeTimer = null;
  function awaken(){
    document.body.classList.add('awake');
    clearTimeout(awakeTimer);
    awakeTimer = setTimeout(() => document.body.classList.remove('awake'), 2200);
  }
  ['pointermove','pointerdown','keydown','touchstart'].forEach(ev=>{
    window.addEventListener(ev, awaken, { passive:true });
  });
  awaken();

  // ----- Input -----
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.key.toLowerCase());
  });
  window.addEventListener('keyup', (e) => {
    keys.delete(e.key.toLowerCase());
  });

  // Nudges: small, because plane flies itself
  const NUDGE = 0.9;
  function nudge(dir){
    awaken();
    targetRoll += dir * NUDGE * 0.10;
    targetYaw  += dir * NUDGE * 0.06;
  }
  zL.addEventListener('pointerdown', ()=>nudge(-1));
  zR.addEventListener('pointerdown', ()=>nudge( 1));
  zC.addEventListener('pointerdown', ()=>{
    awaken();
    targetPitch *= 0.8; targetRoll *= 0.8; targetYaw *= 0.8;
  });

  // ----- Flight State (simple, stable, game-feel) -----
  // Angles in radians
  let pitch = 0;     // nose up/down
  let roll  = 0;     // bank
  let yaw   = 0;     // heading

  let targetPitch = 0;
  let targetRoll  = 0;
  let targetYaw   = 0;

  let throttle = 0.55;   // 0..1
  let speed = 220;       // arbitrary units
  let altitude = 38000;  // feet-ish
  let vspeed = 0;        // vertical speed

  // World position (for cloud parallax)
  let px = 0, py = 0;

  // Tuning: “glide” not twitch
  const maxPitch = 0.28; // ~16 deg
  const maxRoll  = 0.55; // ~32 deg
  const yawRate  = 0.55; // responsiveness

  // ----- Procedural cloud field (2 layers of soft blobs) -----
  function rand(seed){ // deterministic-ish
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }
  const clouds = [];
  const COUNT = 120;
  for(let i=0;i<COUNT;i++){
    const s = i * 12.345;
    clouds.push({
      x: (rand(s) * 2 - 1) * 2200,
      y: (rand(s+1) * 2 - 1) * 1400,
      r: 40 + rand(s+2) * 220,
      l: rand(s+3) < 0.5 ? 0 : 1,
      a: 0.04 + rand(s+4) * 0.10
    });
  }

  // ----- Rendering helpers -----
  function drawSky(w,h){
    // gradient + high altitude hush
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#05060a');
    g.addColorStop(0.22,'#081228');
    g.addColorStop(0.60,'#0b2a55');
    g.addColorStop(1, '#0f4a86');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // faint bright cap
    const cap = ctx.createRadialGradient(w*0.5,h*0.15, 0, w*0.5,h*0.15, Math.max(w,h)*0.8);
    cap.addColorStop(0,'rgba(255,255,255,0.05)');
    cap.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = cap;
    ctx.fillRect(0,0,w,h);
  }

  function drawHorizon(w,h){
    // Horizon tilt from roll, vertical shift from pitch
    const cx = w/2, cy = h/2;
    const tilt = roll;
    const lift = pitch * (h*0.9);

    ctx.save();
    ctx.translate(cx, cy + lift);
    ctx.rotate(-tilt);

    // Thin atmospheric line (barely there)
    ctx.strokeStyle = 'rgba(245,246,255,0.07)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-w, 0);
    ctx.lineTo( w, 0);
    ctx.stroke();

    // Slight haze band
    const haze = ctx.createLinearGradient(0,-120,0,160);
    haze.addColorStop(0,'rgba(255,255,255,0.00)');
    haze.addColorStop(0.50,'rgba(255,255,255,0.03)');
    haze.addColorStop(1,'rgba(255,255,255,0.00)');
    ctx.fillStyle = haze;
    ctx.fillRect(-w, -140, w*2, 280);

    ctx.restore();
  }

  function drawClouds(w,h){
    const cx = w/2, cy = h/2;

    // Parallax: forward motion moves clouds downward; roll/pitch bias lateral shift
    const forward = speed * 0.18;
    const driftX = Math.sin(yaw) * forward * 0.15;

    // Base offsets from world position
    const ox = px * 0.06 + driftX;
    const oy = py * 0.06 + forward;

    for(const c of clouds){
      const layerMul = c.l === 0 ? 0.55 : 0.85;
      const x = cx + (c.x - ox*layerMul) + roll*120*layerMul;
      const y = cy + (c.y - oy*layerMul) + pitch*240*layerMul + h*0.25;

      // Wrap
      if(x < -500 || x > w+500 || y < -500 || y > h+900) continue;

      const rg = ctx.createRadialGradient(x,y, 0, x,y, c.r);
      rg.addColorStop(0, `rgba(255,255,255,${c.a})`);
      rg.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(x,y,c.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  function drawCraft(w,h){
    // Minimal silhouette, center-ish, slightly off
    const cx = w*0.56;
    const cy = h*0.30;

    ctx.save();
    ctx.translate(cx, cy);

    // Small response to roll/pitch (camera-coupled)
    ctx.rotate(roll*0.25);

    // Craft body
    ctx.fillStyle = 'rgba(10,12,18,0.55)';
    ctx.beginPath();
    ctx.moveTo(-120, 22);
    ctx.quadraticCurveTo(-40,-24, 0,-30);
    ctx.quadraticCurveTo(40,-36, 120, 0);
    ctx.quadraticCurveTo(80, 36, 0, 48);
    ctx.quadraticCurveTo(-70, 42, -120, 22);
    ctx.closePath();
    ctx.fill();

    // Ember core
    const ex = 6, ey = 16;
    const eg = ctx.createRadialGradient(ex,ey,0, ex,ey, 26);
    eg.addColorStop(0,'rgba(255,140,70,0.95)');
    eg.addColorStop(0.35,'rgba(255,120,60,0.30)');
    eg.addColorStop(1,'rgba(255,120,60,0.00)');
    ctx.fillStyle = eg;
    ctx.beginPath();
    ctx.arc(ex,ey,26,0,Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawContrail(w,h){
    // Very faint, curves with yaw
    const cx = w*0.56;
    const cy = h*0.30;
    ctx.save();
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = 'rgba(245,246,255,0.75)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6,10]);
    ctx.lineDashOffset = performance.now() * -0.02;

    ctx.beginPath();
    ctx.moveTo(cx-8, cy+18);
    ctx.bezierCurveTo(cx-120, cy+140, cx-260, cy+240, cx-420, cy+420);
    ctx.stroke();
    ctx.restore();
  }

  // ----- Simulation -----
  let last = performance.now();
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function step(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // Inputs (gentle, not arcade twitch)
    const pitchIn = (keys.has('w') ? 1 : 0) + (keys.has('arrowup') ? 1 : 0) - (keys.has('s') ? 1 : 0) - (keys.has('arrowdown') ? 1 : 0);
    const rollIn  = (keys.has('d') ? 1 : 0) - (keys.has('a') ? 1 : 0);
    const yawIn   = (keys.has('e') ? 1 : 0) - (keys.has('q') ? 1 : 0);

    // Throttle (↑/↓) already used for pitch; use R/F for throttle + optional Shift/Ctrl
    const thrIn = (keys.has('r') ? 1 : 0) - (keys.has('f') ? 1 : 0) + (keys.has('shift') ? 1 : 0) - (keys.has('control') ? 1 : 0);

    // Targets are nudges, clamped
    targetPitch = clamp(targetPitch + pitchIn * dt * 0.55, -maxPitch, maxPitch);
    targetRoll  = clamp(targetRoll  + rollIn  * dt * 0.85, -maxRoll,  maxRoll);
    targetYaw   = clamp(targetYaw   + yawIn   * dt * 0.55, -0.9, 0.9);

    // Autostabilization: targets relax toward 0 slowly (plane flies itself)
    const relax = 0.92;
    targetPitch *= Math.pow(relax, dt*60);
    targetRoll  *= Math.pow(relax, dt*60);
    targetYaw   *= Math.pow(relax, dt*60);

    // Throttle changes slowly
    throttle = clamp(throttle + thrIn * dt * 0.25, 0.0, 1.0);

    // Actual angles ease toward target (smooth, weighty)
    pitch = lerp(pitch, targetPitch, 1 - Math.pow(0.86, dt*60));
    roll  = lerp(roll,  targetRoll,  1 - Math.pow(0.82, dt*60));
    yaw   += (targetYaw * yawRate) * dt;

    // Speed responds to throttle; add slight drag with bank/pitch
    const drag = 0.0025 + Math.abs(roll)*0.004 + Math.abs(pitch)*0.006;
    speed += ((throttle*520) - speed) * dt * 0.7;
    speed -= speed * drag * dt * 60;
    speed = clamp(speed, 80, 520);

    // Vertical speed from pitch (scaled), with damping
    vspeed += (pitch * speed * 0.32) * dt * 60;
    vspeed *= Math.pow(0.90, dt*60);
    altitude += vspeed * dt * 2.0;
    altitude = clamp(altitude, 5000, 65000);

    // World movement (forward along yaw)
    const forward = speed * dt * 0.9;
    px += Math.cos(yaw) * forward;
    py += Math.sin(yaw) * forward;

    // Render
    const w = window.innerWidth, h = window.innerHeight;
    drawSky(w,h);
    drawHorizon(w,h);
    drawClouds(w,h);
    drawContrail(w,h);
    drawCraft(w,h);

    // HUD readouts (proof of life)
    spdEl.textContent = Math.round(speed).toString();
    altEl.textContent = Math.round(altitude).toString();
    const hdgDeg = ((yaw * 180/Math.PI) % 360 + 360) % 360;
    hdgEl.textContent = Math.round(hdgDeg).toString().padStart(3,'0');
    thrEl.textContent = Math.round(throttle*100).toString().padStart(2,'0') + '%';

    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

})();
</script>
</body>
</html>
