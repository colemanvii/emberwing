<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emberwing — Cruise (Keys)</title>
  <style>
    :root{
      --ink:#05060a;
      --hud:rgba(245,246,255,.10);
      --hud2:rgba(245,246,255,.18);
      --text:rgba(245,246,255,.62);
      --text2:rgba(245,246,255,.42);
      --ember:rgba(255,140,70,.95);
      --ember2:rgba(255,95,35,.55);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:#000;
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:white;
    }
    canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
      background: radial-gradient(1200px 700px at 50% 15%, rgba(255,255,255,.05), transparent 60%),
                  linear-gradient(to bottom, #05060a 0%, #081228 24%, #0b2a55 58%, #0f4a86 100%);
    }
    .hud{
      position:fixed;
      inset:0;
      pointer-events:none;
      opacity:0;
      transition: opacity 600ms ease;
    }
    .awake .hud{ opacity:1; }

    .hudLine{
      position:absolute; top:10%; bottom:10%;
      width:1px;
      background: linear-gradient(to bottom, transparent 0%, var(--hud) 18%, var(--hud) 82%, transparent 100%);
      filter: blur(.15px);
    }
    .hudLine.left{ left:28px; }
    .hudLine.right{ right:28px; }

    .hudArc{
      position:absolute;
      left:50%; bottom:26px;
      width:min(520px, 78vw);
      height:84px;
      transform:translateX(-50%);
      border-bottom:1px solid var(--hud);
      border-radius: 0 0 999px 999px / 0 0 120px 120px;
      opacity:.9;
    }
    .tick{
      position:absolute; bottom:24px; left:50%;
      width:1px; height:12px;
      transform:translateX(-50%);
      background: linear-gradient(to top, transparent 0%, var(--hud2) 55%, transparent 100%);
      opacity:.6;
    }

    .readouts{
      position:absolute;
      left:26px;
      bottom:26px;
      display:flex;
      gap:18px;
      font-size:12px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--text2);
      user-select:none;
      white-space:nowrap;
    }
    .readouts b{
      color:var(--text);
      font-weight:600;
      letter-spacing:.08em;
      margin-left:6px;
    }

    .hint{
      position:absolute;
      right:26px;
      bottom:26px;
      font-size:12px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:var(--text2);
      opacity:.55;
      user-select:none;
      text-align:right;
      line-height:1.6;
    }

    .toast{
      position:absolute;
      left:50%;
      top:14%;
      transform:translateX(-50%);
      font-size:12px;
      letter-spacing:.18em;
      text-transform:uppercase;
      color:rgba(245,246,255,.55);
      opacity:0;
      transition: opacity 600ms ease;
      user-select:none;
    }
    .toast.on{ opacity:.95; }

    .ember{
      position:absolute;
      left:50%;
      bottom:40px;
      width:10px; height:10px;
      transform:translateX(-50%);
      border-radius:999px;
      background: radial-gradient(circle, var(--ember) 0%, rgba(255,160,90,.75) 22%, rgba(255,120,60,.35) 45%, transparent 70%);
      box-shadow:
        0 0 18px 3px var(--ember2),
        0 0 44px 10px rgba(255,120,60,.12);
      opacity:.85;
      animation: pulse 6.5s ease-in-out infinite;
      will-change: transform, opacity;
    }
    @keyframes pulse{
      0%,100%{ transform:translateX(-50%) scale(.95); opacity:.70 }
      50%{ transform:translateX(-50%) scale(1.10); opacity:.95 }
    }

    .grain{
      position:fixed; inset:-20%;
      pointer-events:none;
      background:
        repeating-linear-gradient(0deg, transparent 0 2px, rgba(255,255,255,.02) 2px 3px),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      mix-blend-mode:overlay;
      opacity:.10;
      animation: grain 7s steps(2,end) infinite;
    }
    @keyframes grain{ 0%{transform:translate3d(0,0,0)} 100%{transform:translate3d(-3%,2%,0)} }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud" id="hud">
    <div class="hudLine left"></div>
    <div class="hudLine right"></div>
    <div class="hudArc"></div>
    <div class="tick"></div>

    <div class="readouts">
      SPD <b id="spd">—</b>
      ALT <b id="alt">—</b>
      HDG <b id="hdg">—</b>
      THR <b id="thr">—</b>
      ASST <b id="asst">HI</b>
    </div>

    <div class="hint">
      ↑↓ pitch · ←→ bank<br/>
      SPACE steady · ENTER ignite<br/>
      CAPS assist
    </div>

    <div class="toast" id="toast">GLIDE CONFIRMED</div>
    <div class="ember" id="ember"></div>
  </div>

  <div class="grain"></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const spdEl  = document.getElementById('spd');
  const altEl  = document.getElementById('alt');
  const hdgEl  = document.getElementById('hdg');
  const thrEl  = document.getElementById('thr');
  const asstEl = document.getElementById('asst');
  const toast  = document.getElementById('toast');
  const ember  = document.getElementById('ember');

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // HUD wake
  let awakeTimer = null;
  function awaken(){
    document.body.classList.add('awake');
    clearTimeout(awakeTimer);
    awakeTimer = setTimeout(() => document.body.classList.remove('awake'), 2200);
  }
  ['pointermove','pointerdown','keydown','touchstart'].forEach(ev=>{
    window.addEventListener(ev, awaken, { passive:true });
  });
  awaken();

  // Keys
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key;
    keys.add(k);

    // Caps toggles assist
    if (k === 'CapsLock') {
      assistHigh = !assistHigh;
      asstEl.textContent = assistHigh ? 'HI' : 'LO';
      softEmber(assistHigh ? 1.05 : 0.95);
    }

    // Enter = ignition / commit
    if (k === 'Enter') {
      throttle = Math.max(throttle, 0.72);
      showToast('GLIDE CONFIRMED');
      softEmber(1.10);
    }

    // Space = steady
    if (k === ' ') {
      steady();
      showToast('STEADY');
      softEmber(1.03);
      e.preventDefault();
    }
  }, { passive:false });

  window.addEventListener('keyup', (e) => {
    keys.delete(e.key);
  });

  // Assist (planes fly themselves)
  let assistHigh = true;

  // Flight state
  let pitch = 0, roll = 0, yaw = 0;
  let targetPitch = 0, targetRoll = 0;

  let throttle = 0.58;   // 0..1
  let speed = 220;
  let altitude = 38000;
  let vspeed = 0;
  let px = 0, py = 0;

  // Limits (glide)
  const maxPitch = 0.28; // ~16deg
  const maxRoll  = 0.55; // ~32deg

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function steady(){
    // hands-off: pull targets toward zero and damp vertical energy
    targetPitch *= 0.35;
    targetRoll  *= 0.35;
    vspeed      *= 0.55;
  }

  let toastTimer = null;
  function showToast(text){
    toast.textContent = text;
    toast.classList.add('on');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toast.classList.remove('on'), 900);
  }

  function softEmber(scale){
    ember.animate(
      [
        { transform:"translateX(-50%) scale(1)" },
        { transform:`translateX(-50%) scale(${scale})` },
        { transform:"translateX(-50%) scale(1)" }
      ],
      { duration: 700, easing:"cubic-bezier(.2,.7,.2,1)" }
    );
  }

  // Procedural clouds
  function rand(seed){
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }
  const clouds = [];
  const COUNT = 130;
  for(let i=0;i<COUNT;i++){
    const s = i * 12.345;
    clouds.push({
      x: (rand(s) * 2 - 1) * 2400,
      y: (rand(s+1) * 2 - 1) * 1600,
      r: 40 + rand(s+2) * 240,
      l: rand(s+3) < 0.5 ? 0 : 1,
      a: 0.04 + rand(s+4) * 0.10
    });
  }

  function drawSky(w,h){
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#05060a');
    g.addColorStop(0.22,'#081228');
    g.addColorStop(0.60,'#0b2a55');
    g.addColorStop(1, '#0f4a86');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const cap = ctx.createRadialGradient(w*0.5,h*0.15, 0, w*0.5,h*0.15, Math.max(w,h)*0.8);
    cap.addColorStop(0,'rgba(255,255,255,0.05)');
    cap.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = cap;
    ctx.fillRect(0,0,w,h);
  }

  function drawHorizon(w,h){
    const cx = w/2, cy = h/2;
    const lift = pitch * (h*0.9);
    ctx.save();
    ctx.translate(cx, cy + lift);
    ctx.rotate(-roll);

    ctx.strokeStyle = 'rgba(245,246,255,0.07)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-w, 0);
    ctx.lineTo( w, 0);
    ctx.stroke();

    const haze = ctx.createLinearGradient(0,-120,0,160);
    haze.addColorStop(0,'rgba(255,255,255,0.00)');
    haze.addColorStop(0.50,'rgba(255,255,255,0.03)');
    haze.addColorStop(1,'rgba(255,255,255,0.00)');
    ctx.fillStyle = haze;
    ctx.fillRect(-w, -140, w*2, 280);

    ctx.restore();
  }

  function drawClouds(w,h){
    const cx = w/2, cy = h/2;
    const forward = speed * 0.18;

    const ox = px * 0.06;
    const oy = py * 0.06 + forward;

    for(const c of clouds){
      const layerMul = c.l === 0 ? 0.55 : 0.85;
      const x = cx + (c.x - ox*layerMul) + roll*120*layerMul;
      const y = cy + (c.y - oy*layerMul) + pitch*240*layerMul + h*0.25;

      if(x < -600 || x > w+600 || y < -600 || y > h+1000) continue;

      const rg = ctx.createRadialGradient(x,y, 0, x,y, c.r);
      rg.addColorStop(0, `rgba(255,255,255,${c.a})`);
      rg.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(x,y,c.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  function drawCraft(w,h){
    const cx = w*0.56, cy = h*0.30;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(roll*0.25);

    ctx.fillStyle = 'rgba(10,12,18,0.55)';
    ctx.beginPath();
    ctx.moveTo(-120, 22);
    ctx.quadraticCurveTo(-40,-24, 0,-30);
    ctx.quadraticCurveTo(40,-36, 120, 0);
    ctx.quadraticCurveTo(80, 36, 0, 48);
    ctx.quadraticCurveTo(-70, 42, -120, 22);
    ctx.closePath();
    ctx.fill();

    const ex = 6, ey = 16;
    const eg = ctx.createRadialGradient(ex,ey,0, ex,ey, 26);
    eg.addColorStop(0,'rgba(255,140,70,0.95)');
    eg.addColorStop(0.35,'rgba(255,120,60,0.30)');
    eg.addColorStop(1,'rgba(255,120,60,0.00)');
    ctx.fillStyle = eg;
    ctx.beginPath();
    ctx.arc(ex,ey,26,0,Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawContrail(w,h,now){
    const cx = w*0.56, cy = h*0.30;
    ctx.save();
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = 'rgba(245,246,255,0.75)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6,10]);
    ctx.lineDashOffset = now * -0.02;

    ctx.beginPath();
    ctx.moveTo(cx-8, cy+18);
    ctx.bezierCurveTo(cx-120, cy+140, cx-260, cy+240, cx-420, cy+420);
    ctx.stroke();
    ctx.restore();
  }

  // Sim loop
  let last = performance.now();
  let t = 0;

  function step(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    t += dt;

    // Arrow keys as basic directional buttons
    const up    = keys.has('ArrowUp');
    const down  = keys.has('ArrowDown');
    const left  = keys.has('ArrowLeft');
    const right = keys.has('ArrowRight');
    const space = keys.has(' ');

    // Each press nudges targets; assist determines how fast we recenter
    const pitchNudge = (up ? 1 : 0) - (down ? 1 : 0);
    const rollNudge  = (right ? 1 : 0) - (left ? 1 : 0);

    // Nudge speed (small, steady)
    const nudgeRatePitch = 0.42;
    const nudgeRateRoll  = 0.65;

    targetPitch = clamp(targetPitch + pitchNudge * dt * nudgeRatePitch, -maxPitch, maxPitch);
    targetRoll  = clamp(targetRoll  + rollNudge  * dt * nudgeRateRoll,  -maxRoll,  maxRoll);

    if (space) steady();

    // Autostabilize targets (plane flies itself)
    const relaxPerSec = assistHigh ? 2.2 : 0.9; // HIGH = returns faster to center
    const relax = Math.exp(-relaxPerSec * dt);
    targetPitch *= relax;
    targetRoll  *= relax;

    // Actual angles ease toward targets
    const pitchEase = 1 - Math.pow(assistHigh ? 0.82 : 0.90, dt*60);
    const rollEase  = 1 - Math.pow(assistHigh ? 0.78 : 0.88, dt*60);
    pitch = lerp(pitch, targetPitch, pitchEase);
    roll  = lerp(roll,  targetRoll,  rollEase);

    // Heading changes gently with bank (coordinated turn feel)
    const turnRate = assistHigh ? 0.35 : 0.55;
    yaw += (roll * turnRate) * dt;

    // Speed responds to throttle; simple drag
    const drag = 0.0025 + Math.abs(roll)*0.004 + Math.abs(pitch)*0.006;
    speed += ((throttle*520) - speed) * dt * 0.7;
    speed -= speed * drag * dt * 60;
    speed = clamp(speed, 80, 520);

    // Altitude responds to pitch
    vspeed += (pitch * speed * 0.32) * dt * 60;
    vspeed *= Math.pow(assistHigh ? 0.90 : 0.94, dt*60);
    altitude += vspeed * dt * 2.0;
    altitude = clamp(altitude, 5000, 65000);

    // World forward motion
    const forward = speed * dt * 0.9;
    px += Math.cos(yaw) * forward;
    py += Math.sin(yaw) * forward;

    // Render
    const w = window.innerWidth, h = window.innerHeight;
    drawSky(w,h);
    drawHorizon(w,h);
    drawClouds(w,h);
    drawContrail(w,h,now);
    drawCraft(w,h);

    // HUD readouts (proof of life)
    spdEl.textContent = String(Math.round(speed));
    altEl.textContent = String(Math.round(altitude));
    const hdgDeg = ((yaw * 180/Math.PI) % 360 + 360) % 360;
    hdgEl.textContent = String(Math.round(hdgDeg)).padStart(3,'0');
    thrEl.textContent = String(Math.round(throttle*100)).padStart(2,'0') + '%';

    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
